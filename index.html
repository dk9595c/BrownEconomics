<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Faculty Scheduler</title>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0 auto;
            padding: 20px;
            max-width: 1200px;
            background-color: #f4f4f9;
            color: #333;
        }
        h1 {
            color: #004a9c;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
        }
        
        /* --- Navigation Styles --- */
        nav {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        nav button {
            font-size: 1.1em;
            padding: 10px 15px;
            border: none;
            background-color: #ddd;
            color: #333;
            cursor: pointer;
            border-radius: 5px;
        }
        nav button.active {
            background-color: #004a9c;
            color: white;
            font-weight: bold;
        }
        #rerun-button {
            background-color: #1a73e8;
            color: white;
            margin-left: auto; /* Pushes it to the right */
        }
        #rerun-button:hover {
            background-color: #185abc;
        }
        /* --- End Nav Styles --- */

        #status-message {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px; /* Reduced margin */
            padding: 15px;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
        }
        #status-message.success {
            color: #155724;
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }
        #status-message.failure {
            color: #721c24;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        #status-message.improved {
            color: #004085;
            background-color: #cce5ff;
            border: 1px solid #b8daff;
        }
        
        /* --- Progress Bar Styles --- */
        #progress-container {
            width: 100%;
            margin-bottom: 20px;
            display: none; /* Hidden by default */
        }
        #stats-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
            font-family: monospace;
            color: #333;
        }
        
        #progress-bar-outline {
            width: 100%;
            height: 20px;
            background-color: #eee;
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow: hidden;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background-color: #004a9c;
            transition: width 0.1s linear;
        }
        #progress-label {
            text-align: left; /* Anchored to the left */
            font-style: italic;
            margin-top: 5px;
            color: #555;
        }
        /* --- End Progress Bar Styles --- */
        
        .card-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        .schedule-card {
            background-color: #ffffff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        .card-header {
            font-weight: bold;
            background-color: #f9f9f9;
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
            color: #004a9c;
        }
        .card-body {
            padding: 15px;
            font-size: 1.0em;
            color: #444;
            line-height: 1.7;
        }
        .card-body strong { color: #000; } /* Default 'happy' style */
        .card-body em { color: #888; }
        
        /* --- CSS FIX: Increased specificity --- */
        .card-body strong.unhappy {
            color: #DBDBDB; /* Light Grey Text */
            background-color: crimson; /* Crimson Red Background */
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>

    <h1>Faculty Scheduler (55 Faculty)</h1>
    
    <nav>
        <button id="nav-scheduler" class="active">Scheduler Result</button>
        <button id="nav-availability">Faculty Availability</button>
        <button id="rerun-button">Generate New Schedule</button>
    </nav>
    
    <main id="page-scheduler">
        <div id="status-message">Loading...</div>
        
        <div id="progress-container">
            <div id="stats-container">
                <div id="timer-label">Time: 0.0s</div>
                <div id="combo-label">Combinations: 0</div>
            </div>
            <div id="progress-bar-outline">
                <div id="progress-bar"></div>
            </div>
            <div id="progress-label">Starting...</div>
        </div>
        
        <div id="schedule-container" class="card-container"></div>
    </main>
    
    <main id="page-availability" style="display: none;">
        <h2>Faculty Availability (55 Faculty)</h2>
        <div id="availability-container" class="card-container"></div>
    </main>

    <script>
        
        // --- HELPER FUNCTIONS (shuffle, formatTime, yield) ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        function formatTime(totalSeconds) {
            if (totalSeconds >= 3600) {
                const hours = Math.floor(totalSeconds / 3600);
                const remainingSeconds = totalSeconds % 3600;
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                return `Time: ${hours}h ${minutes}m ${seconds.toFixed(1)}s`;
            }
            if (totalSeconds >= 60) {
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `Time: ${minutes}m ${seconds.toFixed(1)}s`;
            }
            return `Time: ${totalSeconds.toFixed(1)}s`;
        }
        
        function yieldToBrowser() {
            return new Promise(resolve => setTimeout(resolve, 0));
        }

        // --- PROCEDURAL DATA GENERATION ---
        function generateTestData(numFaculty, numTimeSlots) {
            // ... (This function is unchanged) ...
            const allFaculty = [];
            let allTimeSlots = [];
            const allLectureSlots = [];
            const teacherAvailabilityMap = new Map();
            const lastNames = [
                'Adams', 'Baker', 'Chen', 'Davis', 'Elara', 'Faruqi', 'Gupta', 'Hernandez', 'Imani', 'Jones',
                'Kim', 'Lee', 'Miller', 'Ngo', 'Okafor', 'Patel', 'Quinn', 'Rossi', 'Smith', 'Tanaka',
                'Umar', 'Volkov', 'Walker', 'Xiong', 'Yilmaz', 'Zhang', 'Adebayo', 'Bose', 'Chavez', 'Dubois',
                'Erikson', 'Fisher', 'Gomez', 'Huxley', 'Ivanov', 'Jang', 'Kaur', 'Lopez', 'Mbeki', 'Nguyen',
                'Perez', 'Ramos', 'Silva', 'Torres', 'Vargas', 'Wang', 'Yates', 'Zimmerman', 'Ali', 'Bedi',
                'Cabrera', 'Deng', 'Escobar', 'Flores', 'Gagnon'
            ];
            for (let i = 0; i < numFaculty; i++) {
                const facultyName = `F${i + 1}_${lastNames[i % lastNames.length]}`;
                allFaculty.push(facultyName);
                teacherAvailabilityMap.set(facultyName, []);
            }
            const slotNamePool = [
                'MWF 9-10', 'MWF 10-11', 'MWF 11-12', 'MWF 1-2', 'MWF 2-3',
                'TTh 9-10:30', 'TTh 10:30-12', 'TTh 1-2:30', 'TTh 2:30-4',
                'M 1-2', 'M 2-3', 'M 3-4', 'T 1-2', 'T 2-3', 'W 1-2', 'W 2-3', 'W 3-4',
                'Th 1-2', 'Th 2-3', 'F 1-2', 'F 2-3', 'F 3-4'
            ];
            allTimeSlots = shuffleArray(slotNamePool).slice(0, numTimeSlots);
            for (const slot of allTimeSlots) {
                const numRooms = Math.floor(Math.random() * (6 - 1 + 1)) + 1; // 1-6 rooms
                for (let i = 1; i <= numRooms; i++) {
                    allLectureSlots.push({ id: `${slot} (Room ${i})`, timeSlot: slot });
                }
            }
            const minAvail = 2; const maxAvail = 5;
            for (const faculty of allFaculty) {
                const shuffledTimeSlots = shuffleArray([...allTimeSlots]);
                const numAvailable = Math.floor(Math.random() * (maxAvail - minAvail + 1)) + minAvail;
                const availableSlots = shuffledTimeSlots.slice(0, numAvailable);
                teacherAvailabilityMap.set(faculty, availableSlots);
            }
            return { allFaculty, allTimeSlots, allLectureSlots, teacherAvailabilityMap };
        }
        
        // --- Helper: Update Progress Bar ---
        function updateProgress(facultyIndex, totalFaculty, facultyName, progressBar, progressLabel, combinations, comboLabel) {
            const percentage = (facultyIndex / totalFaculty) * 100;
            progressBar.style.width = percentage + '%';
            
            if (facultyIndex === totalFaculty) {
                progressLabel.textContent = "Search complete!";
            } else if (facultyName) {
                progressLabel.textContent = `Optimizing: ${facultyName} (${facultyIndex}/${totalFaculty})...`;
            } else {
                progressLabel.textContent = "Starting optimization search...";
            }
            
            comboLabel.textContent = `Combinations: ${combinations.toLocaleString()}`;
        }
        
        // --- PHASE 1: FAST HEURISTIC SOLVER ---
        function runHeuristicSolver(allFaculty, allLectureSlots, teacherAvailabilityMap) {
            const schedule = new Map(); // Faculty -> { lecture, isHappy }
            const assignedLectureSlots = new Set();
            const facultyTimeSlotMap = new Map();
            let numUnhappy = 0;

            const allAvailableLectureSlots = new Set(allLectureSlots);
            
            const lectureSlotsByTime = new Map();
            for (const lecture of allLectureSlots) {
                if (!lectureSlotsByTime.has(lecture.timeSlot)) {
                    lectureSlotsByTime.set(lecture.timeSlot, []);
                }
                lectureSlotsByTime.get(lecture.timeSlot).push(lecture);
            }

            // 1. Sort faculty by "Minimum Remaining Values" (MRV) heuristic
            const sortedFaculty = [...allFaculty].sort((a, b) => {
                const aSlots = teacherAvailabilityMap.get(a) || [];
                const bSlots = teacherAvailabilityMap.get(b) || [];
                return aSlots.length - bSlots.length;
            });

            // 2. One-pass greedy assignment
            for (const faculty of sortedFaculty) {
                const assignedTimesForThisFaculty = facultyTimeSlotMap.get(faculty) || new Set();
                let placed = false;

                // --- Try to place in a "happy" slot first ---
                const preferredTimeSlots = teacherAvailabilityMap.get(faculty) || [];
                for (const timeSlot of preferredTimeSlots) {
                    if (!assignedTimesForThisFaculty.has(timeSlot)) {
                        const lecturesInSlot = lectureSlotsByTime.get(timeSlot) || [];
                        for (const lecture of lecturesInSlot) {
                            if (!assignedLectureSlots.has(lecture.id)) {
                                schedule.set(faculty, { lecture, isHappy: true });
                                assignedLectureSlots.add(lecture.id);
                                assignedTimesForThisFaculty.add(lecture.timeSlot);
                                facultyTimeSlotMap.set(faculty, assignedTimesForThisFaculty);
                                placed = true;
                                break;
                            }
                        }
                    }
                    if (placed) break;
                }

                // --- If not placed, place in *any* "unhappy" slot ---
                if (!placed) {
                    for (const lecture of allLectureSlots) {
                        if (!assignedLectureSlots.has(lecture.id) && !assignedTimesForThisFaculty.has(lecture.timeSlot)) {
                            schedule.set(faculty, { lecture, isHappy: false });
                            assignedLectureSlots.add(lecture.id);
                            assignedTimesForThisFaculty.add(lecture.timeSlot);
                            facultyTimeSlotMap.set(faculty, assignedTimesForThisFaculty);
                            numUnhappy++;
                            placed = true;
                            break;
                        }
                    }
                }
                
                if (!placed) {
                    console.error("Heuristic failed to place " + faculty);
                }
            }
            
            return { schedule, numUnhappy };
        }


        // --- PHASE 2: ASYNC OPTIMIZATION SOLVER ---
        async function solveFullSearch(allFaculty, allLectureSlots, teacherAvailabilityMap, progressBar, progressLabel, comboLabel, progressState, updateCallback, initialBestScore) {
            
            const schedule = new Map();
            const assignedLectureSlots = new Set();
            const facultyTimeSlotMap = new Map();
            
            progressState.bestScore = initialBestScore;
            
            const lectureSlotsByTime = new Map();
            for (const lecture of allLectureSlots) {
                if (!lectureSlotsByTime.has(lecture.timeSlot)) {
                    lectureSlotsByTime.set(lecture.timeSlot, []);
                }
                lectureSlotsByTime.get(lecture.timeSlot).push(lecture);
            }
            const facultyPreferredSlots = new Map();
            for(const [faculty, slots] of teacherAvailabilityMap.entries()) {
                facultyPreferredSlots.set(faculty, new Set(slots));
            }

            // --- Recursive helper is now ASYNC ---
            async function solveForFaculty(facultyIndex, currentUnhappy) {
                
                // --- Pruning (Branch and Bound) ---
                if (currentUnhappy >= progressState.bestScore) {
                    return; // This path is already worse or equal, so stop.
                }

                progressState.facultyIndex = facultyIndex;
                
                // --- Base Case ---
                if (facultyIndex === allFaculty.length) {
                    // We found a new, better solution!
                    progressState.bestScore = currentUnhappy;
                    updateCallback(new Map(schedule), currentUnhappy); // Send a *copy*
                    return;
                }
                
                const faculty = allFaculty[facultyIndex];
                
                if(progressState.combinations % 500 === 0) { // Only update UI every 500 combos
                    updateProgress(facultyIndex, allFaculty.length, faculty, progressBar, progressLabel, progressState.combinations, comboLabel);
                    await yieldToBrowser();
                }

                // --- Resume logic ---
                const assignedTimesForThisFaculty = facultyTimeSlotMap.get(faculty) || new Set();
                const preferredSlots = facultyPreferredSlots.get(faculty) || new Set();

                const possibleLectures = [];
                for (const lecture of allLectureSlots) {
                    if (!assignedLectureSlots.has(lecture.id) && !assignedTimesForThisFaculty.has(lecture.timeSlot)) {
                        const isHappy = preferredSlots.has(lecture.timeSlot);
                        possibleLectures.push({ lecture, isHappy });
                    }
                }
                
                possibleLectures.sort((a, b) => b.isHappy - a.isHappy); // true (1) before false (0)
                
                for (const { lecture, isHappy } of possibleLectures) {
                    progressState.combinations++;
                    
                    const newUnhappy = currentUnhappy + (isHappy ? 0 : 1);
                    
                    schedule.set(faculty, { lecture, isHappy });
                    assignedLectureSlots.add(lecture.id);
                    assignedTimesForThisFaculty.add(lecture.timeSlot);
                    facultyTimeSlotMap.set(faculty, assignedTimesForThisFaculty);
                    
                    await solveForFaculty(facultyIndex + 1, newUnhappy);

                    schedule.delete(faculty);
                    assignedLectureSlots.delete(lecture.id);
                    assignedTimesForThisFaculty.delete(lecture.timeSlot);
                }
            }

            const shuffledFaculty = shuffleArray([...allFaculty]);
            await solveForFaculty(0, 0); // Start the search

            return {
                message: `Optimization search complete. Best score: ${progressState.bestScore} conflicts.`,
            };
        }
        
        
        // --- Function to render the Faculty Availability page ---
        function renderAvailabilityPage(allFaculty, teacherAvailabilityMap, container) {
            let htmlContent = "";
            const sortedFaculty = [...allFaculty].sort();
            
            for (const faculty of sortedFaculty) {
                const availableSlots = teacherAvailabilityMap.get(faculty) || [];
                const sortedSlots = [...availableSlots].sort();
                
                htmlContent += `
                    <div class="schedule-card">
                        <div class="card-header">${faculty}</div>
                        <div class="card-body">
                            ${sortedSlots.join('<br>')}
                        </div>
                    </div>
                `;
            }
            container.innerHTML = htmlContent;
        }

        // --- Function to render the Schedule (so it can be re-called) ---
        function renderSchedulerPage(schedule, allTimeSlots, allLectureSlots, containerEl) {
            // 1. Invert the schedule map for easy lookup
            const assignedLecturesMap = new Map();
            for (const [faculty, assignment] of schedule.entries()) {
                assignedLecturesMap.set(assignment.lecture.id, { faculty, isHappy: assignment.isHappy });
            }

            // 2. Group all lecture slots by their TimeSlot
            const timeSlotGrouping = new Map();
            for (const timeSlot of allTimeSlots) {
                timeSlotGrouping.set(timeSlot, []); // Initialize
            }
            
            for (const lecture of allLectureSlots) {
                const roomName = lecture.id.substring(lecture.timeSlot.length).trim();
                const assignment = assignedLecturesMap.get(lecture.id);
                
                let assignmentString;
                if (assignment) {
                    // Apply 'unhappy' class if needed
                    const unhappyClass = assignment.isHappy ? '' : 'class="unhappy"';
                    assignmentString = `${roomName}: <strong ${unhappyClass}>${assignment.faculty}</strong>`;
                } else {
                    assignmentString = `${roomName}: <em>(Unassigned)</em>`;
                }
                timeSlotGrouping.get(lecture.timeSlot).push(assignmentString);
            }

            // 3. Build the final HTML
            let htmlContent = "";
            const sortedTimeSlots = [...allTimeSlots].sort();
            
            for (const timeSlot of sortedTimeSlots) {
                const assignments = timeSlotGrouping.get(timeSlot) || [];
                
                htmlContent += `
                    <div class="schedule-card">
                        <div class="card-header">${timeSlot}</div>
                        <div class="card-body">
                            ${assignments.join('<br>')}
                        </div>
                    </div>
                `;
            }
            containerEl.innerHTML = htmlContent;
        }


        // --- This code runs after the page loads ---
        document.addEventListener("DOMContentLoaded", async function() {
            
            // --- Get ALL DOM elements ONCE ---
            const navScheduler = document.getElementById("nav-scheduler");
            const navAvailability = document.getElementById("nav-availability");
            const rerunButton = document.getElementById("rerun-button");
            
            const pageScheduler = document.getElementById("page-scheduler");
            const pageAvailability = document.getElementById("page-availability");
            
            const statusEl = document.getElementById("status-message");
            const scheduleContainer = document.getElementById("schedule-container");
            const availabilityContainer = document.getElementById("availability-container");
            
            const progressContainer = document.getElementById("progress-container");
            const progressBar = document.getElementById("progress-bar");
            const progressLabel = document.getElementById("progress-label");
            
            const timerLabel = document.getElementById("timer-label");
            const comboLabel = document.getElementById("combo-label");
            
            let timerInterval = null;
            let progressState = {
                facultyIndex: 0,
                combinations: 0,
                bestScore: Infinity // The score to beat
            };
            const NUM_FACULTY = 55;
            const NUM_SLOTS = 20;

            // --- Main execution function ---
            async function runScheduler() {
                // 1. Clear old results and show progress bar
                rerunButton.disabled = true;
                rerunButton.textContent = "Computing...";
                statusEl.textContent = "Generating new data...";
                statusEl.className = "";
                scheduleContainer.innerHTML = "";
                availabilityContainer.innerHTML = "";
                
                // --- Reset UI ---
                progressContainer.style.display = "block";
                timerLabel.textContent = "Time: 0.0s";
                comboLabel.textContent = "Combinations: 0";
                
                progressState.facultyIndex = 0;
                progressState.combinations = 0;
                progressState.bestScore = Infinity; // Reset best score
                
                updateProgress(0, NUM_FACULTY, null, progressBar, progressLabel, 0, comboLabel);

                // 2. Generate Data
                const { allFaculty, allTimeSlots, allLectureSlots, teacherAvailabilityMap } = generateTestData(NUM_FACULTY, NUM_SLOTS);

                // 3. Render Availability Page
                renderAvailabilityPage(allFaculty, teacherAvailabilityMap, availabilityContainer);
                
                // 4. --- PHASE 1: Run Fast Heuristic (SYNC) ---
                statusEl.textContent = "Finding initial heuristic solution...";
                const heuristicResult = runHeuristicSolver(allFaculty, allLectureSlots, teacherAvailabilityMap);
                progressState.bestScore = heuristicResult.numUnhappy; // Set the score to beat
                
                // Render the first solution
                renderSchedulerPage(heuristicResult.schedule, allTimeSlots, allLectureSlots, scheduleContainer);
                statusEl.textContent = `Heuristic solution found with ${progressState.bestScore} conflicts. Now searching for a better one...`;
                statusEl.className = "success"; // Mark as success for now
                
                
                // 5. --- Setup Timer (for Phase 2) ---
                const startTime = performance.now();
                if (timerInterval) clearInterval(timerInterval);
                
                timerInterval = setInterval(() => {
                    const elapsedSeconds = ((performance.now() - startTime) / 1000);
                    timerLabel.textContent = formatTime(elapsedSeconds);
                }, 100);

                // 6. --- PHASE 2: Run Full Optimization (ASYNC) ---
                
                // This callback will be triggered by the solver
                const updateCallback = (newSchedule, newScore) => {
                    renderSchedulerPage(newSchedule, allTimeSlots, allLectureSlots, scheduleContainer);
                    
                    // *** EMOJI REMOVED HERE ***
                    statusEl.textContent = `New best solution found! Conflicts: ${newScore}`;
                    statusEl.className = "improved";
                };
                
                const result = await solveFullSearch(
                    allFaculty, allLectureSlots, teacherAvailabilityMap,
                    progressBar, progressLabel, comboLabel,
                    progressState, updateCallback, progressState.bestScore
                );
                
                // 7. --- Cleanup ---
                clearInterval(timerInterval);
                timerInterval = null;
                const endTime = performance.now();
                const durationInSeconds = (endTime - startTime) / 1000;

                // 8. Hide progress bar & Set Final Message
                progressContainer.style.display = "none";
                const finalCombinations = progressState.combinations.toLocaleString();
                
                if (progressState.bestScore < heuristicResult.numUnhappy) {
                    statusEl.textContent = `Search complete! Final best score: ${progressState.bestScore} conflicts. (Searched ${finalCombinations} combinations in ${durationInSeconds.toFixed(3)}s)`;
                    statusEl.className = "success";
                } else {
                    statusEl.textContent = `Search complete. Heuristic was optimal. Score: ${progressState.bestScore} conflicts. (Searched ${finalCombinations} combinations in ${durationInSeconds.toFixed(3)}s)`;
                    statusEl.className = "success";
                }

                // 9. Re-enable rerun button
                rerunButton.disabled = false;
                rerunButton.textContent = "Generate New Schedule";
            }
            
            // --- SET UP NAVIGATION CLICK HANDLERS ---
            navScheduler.addEventListener("click", () => {
                pageScheduler.style.display = "block";
                pageAvailability.style.display = "none";
                navScheduler.classList.add("active");
                navAvailability.classList.remove("active");
            });
            
            navAvailability.addEventListener("click", () => {
                pageScheduler.style.display = "none";
                pageAvailability.style.display = "block";
                navScheduler.classList.remove("active");
                navAvailability.classList.add("active");
            });
            
            // --- SET UP RERUN BUTTON CLICK HANDLER ---
            rerunButton.addEventListener("click", runScheduler);
            
            // --- INITIAL RUN ON PAGE LOAD ---
            await runScheduler();
            
        });

    </script>

</body>
</html>
