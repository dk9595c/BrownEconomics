<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Faculty Scheduler</title>
    
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0 auto; padding: 20px; max-width: 1200px; background-color: #f4f4f9; color: #333; }
        h1 { color: #004a9c; border-bottom: 2px solid #ddd; padding-bottom: 10px; }
        h2 { color: #004a9c; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-top: 30px; }
        h3 { color: #333; margin-top: 25px; margin-bottom: 10px; border-bottom: 1px dashed #ccc; padding-bottom: 5px; }
        nav { margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
        nav button { font-size: 1.0em; padding: 8px 12px; border: none; background-color: #ddd; color: #333; cursor: pointer; border-radius: 5px; transition: background-color 0.2s; margin-right: 5px; }
        nav button:hover { background-color: #ccc; }
        nav button.active { background-color: #004a9c; color: white; font-weight: bold; }
        .page-section { display: none; }
        .page-section.active-section { display: block; }
        #upload-container { padding: 20px; background-color: #fff; border: 2px dashed #004a9c; border-radius: 8px; margin-bottom: 20px; text-align: center; }
        #upload-container label { font-weight: bold; font-size: 1.1em; color: #004a9c; margin-right: 10px; }
        #file-uploader { border: 1px solid #ccc; padding: 5px; border-radius: 4px; }
        #parse-status { margin-top: 10px; font-style: italic; font-size: 0.9em; }
        #course-requirement-warning { padding: 30px; background-color: #fff3cd; border: 1px solid #ffeeba; border-radius: 8px; color: #856404; text-align: center; margin-bottom: 20px; display: none; }
        #course-requirement-warning button { margin-top: 15px; padding: 10px 20px; background-color: #856404; color: white; border: none; border-radius: 5px; cursor: pointer; }
        #course-requirement-warning button:hover { background-color: #6d5204; }
        #assignment-area { margin-top: 20px; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); display: none; }
        table.assignment-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
        table.assignment-table th, table.assignment-table td { text-align: left; padding: 12px; border-bottom: 1px solid #eee; vertical-align: top; }
        table.assignment-table th { background-color: #f9f9f9; color: #004a9c; }
        .assignment-row { display: flex; gap: 5px; margin-bottom: 8px; align-items: center; }
        .assignment-row select { padding: 6px; border: 1px solid #ccc; border-radius: 4px; }
        .assignment-row select.course-select { width: 200px; }
        .assignment-row select.section-select { width: 110px; }
        .btn-remove-assign { background: #dc3545; color: #fff; border: none; border-radius: 4px; cursor: pointer; padding: 0 6px; height: 30px; line-height: 30px; font-size: 16px; }
        .btn-add-assign { background: #28a745; color: #fff; border: none; border-radius: 4px; cursor: pointer; padding: 6px 12px; font-size: 0.9em; }
        #generate-btn { display: block; width: 100%; padding: 15px; background-color: #28a745; color: white; border: none; border-radius: 5px; font-size: 1.2em; cursor: pointer; transition: background-color 0.2s; }
        #generate-btn:hover { background-color: #218838; }
        #generate-btn:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.6; }
        #course-entry-container { background-color: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); }
        #course-form { display: grid; grid-template-columns: 1fr 120px; gap: 10px; margin-bottom: 20px; align-items: center; border-bottom: 1px dashed #eee; padding-bottom: 15px; }
        #course-form input[type="text"] { padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1.0em; }
        #course-form button { padding: 10px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #course-form button:hover { background-color: #0056b3; }
        #course-list { list-style: none; padding: 0; }
        #course-list li { background-color: #f9f9f9; border: 1px solid #eee; padding: 10px 15px; margin-bottom: 8px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }
        #course-list li span.course-details { font-weight: bold; color: #333; }
        #course-list li button.remove-btn { background-color: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8em; transition: background-color 0.2s; }
        #course-list li button.remove-btn:hover { background-color: #c82333; }
        #status-message { font-size: 1.1em; font-weight: bold; margin-bottom: 10px; padding: 12px; border-radius: 5px; transition: background-color 0.3s, color 0.3s; border: 1px solid transparent; display: none; }
        #status-message.success { display: block; color: #155724; background-color: #d4edda; border-color: #c3e6cb; }
        #status-message.failure { display: block; color: #721c24; background-color: #f8d7da; border-color: #f5c6cb; }
        #status-message.improved { display: block; color: #004085; background-color: #cce5ff; border-color: #b8daff; }
        #status-message.info { display: block; color: #0c5460; background-color: #d1ecf1; border-color: #bee5eb; }
        #progress-container { width: 100%; margin-bottom: 20px; display: none; }
        #stats-container { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.9em; font-family: monospace; color: #333; }
        #progress-bar-outline { width: 100%; height: 20px; background-color: #eee; border: 1px solid #ccc; border-radius: 5px; overflow: hidden; }
        #progress-bar { width: 0%; height: 100%; background-color: #004a9c; transition: width 0.1s linear; }
        #progress-label { text-align: left; font-style: italic; margin-top: 5px; color: #555; }
        .card-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .schedule-card { background-color: #ffffff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); overflow: hidden; }
        .card-header { font-weight: bold; background-color: #f9f9f9; padding: 12px 15px; border-bottom: 1px solid #eee; color: #004a9c; }
        .card-body { padding: 15px; font-size: 1.0em; color: #444; line-height: 1.7; }
        .card-body strong { color: #000; } .card-body em { color: #888; }
        .card-body strong.unhappy { color: #B22222; background-color: #f8d7da; font-weight: bold; padding: 2px 4px; border-radius: 3px; }
        
        /* Highlight style for hardcoded slots */
        .card-body strong.hardcoded { 
            color: #004085; 
            background-color: #cce5ff; 
            font-weight: bold; 
            padding: 2px 4px; 
            border-radius: 3px; 
            border: 1px solid #b8daff;
        }

        .course-tag { display: inline-block; background-color: #f0f0f0; color: #555; padding: 1px 6px; border-radius: 4px; font-size: 0.85em; margin-left: 8px; border: 1px solid #ddd; vertical-align: middle; }
        #multi-schedule-results-area { display: none; }
        details.heuristic-details { border: 1px solid #ddd; border-radius: 8px; background-color: #fdfdfd; margin-bottom: 10px; }
        summary.heuristic-summary { font-size: 1.25em; font-weight: bold; color: #333; padding: 12px 15px; cursor: pointer; list-style: none; }
        summary.heuristic-summary::-webkit-details-marker { display: none; }
        details[open] > summary.heuristic-summary::before { content: '▼ '; }
        details > summary.heuristic-summary::before { content: '▶ '; font-size: 0.8em; margin-right: 8px; transition: transform 0.1s linear; }
        div.heuristic-content { padding: 0 15px 15px 35px; border-top: 1px dashed #ccc; }

        /* Hardcode Section Styles */
        #hardcode-section {
            background-color: #eef2f7;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid #ced4da;
            display: none;
        }
        .hardcode-controls {
            margin-bottom: 15px;
            text-align: center;
        }
        .hardcode-controls button {
            background-color: #17a2b8;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }
        .hardcode-controls button:hover {
            background-color: #138496;
        }
        .hardcode-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .hardcode-row {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #fff;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .hardcode-row select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            flex-grow: 1;
        }
        .hardcode-row button.remove-hc {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-weight: bold;
        }
        
        #assignment-message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        #assignment-message.info-msg {
            background-color: #e2e3e5;
            color: #383d41;
            border: 1px solid #d6d8db;
        }
        #assignment-message.empty-msg {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
    </style>
</head>
<body>

    <h1>Faculty Scheduler</h1>

    <nav>
        <button id="nav-courses" class="active" onclick="switchPage('courses')">1. Course Entry</button>
        <button id="nav-faculty" onclick="switchPage('faculty')">2. Faculty & Assignments</button>
        <button id="nav-results" onclick="switchPage('results')">3. Schedule Results</button>
        <button id="nav-availability" onclick="switchPage('availability')">4. Availability</button>
    </nav>
    
    <main id="page-courses" class="page-section active-section">
        <h2>Course Management</h2>
        <div id="course-entry-container">
            <h3>Add New Course</h3>
            <div id="course-form">
                <input type="text" id="course-name-input" placeholder="Course Name (e.g., Intro to CS, CHEM 101)" required>
                <button id="add-course-btn">Add Course</button>
            </div>
            <h3>Current Courses (<span id="course-count">0</span>)</h3>
            <ul id="course-list"></ul>
        </div>
    </main>

    <main id="page-faculty" class="page-section">
        <h2>Faculty & Assignments</h2>
        
        <div id="course-requirement-warning">
            <h3>Prerequisites Not Met</h3>
            <p>You must add at least one course in "Course Entry" before uploading a schedule.</p>
            <button onclick="switchPage('courses')">Go to Course Entry</button>
        </div>

        <div id="upload-container">
            <label for="file-uploader">Upload Schedule File (.xlsm, .xlsx):</label>
            <input type="file" id="file-uploader" accept=".xlsx, .xlsm" />
            <div id="parse-status">Please select a file to begin.</div>
        </div>

        <!-- NEW: Hardcode Section -->
        <div id="hardcode-section">
            <h3>Hardcode Courses (Pre-assign)</h3>
            <p style="font-size: 0.9em; color: #555; margin-bottom:10px;">
                Add specific assignments here to lock a faculty member and their course into a specific time slot.
                <br><b>Note:</b> Hardcoded courses do not consume a regular room from the count, but they still respect faculty availability and course conflict rules.
                <br><strong style="color: #dc3545;">Warning:</strong> Faculty cannot be assigned to teach on all 5 days (Mon-Fri).
            </p>
            <div class="hardcode-controls">
                <button onclick="addHardcodeRow()">+ Add Pre-Assignment</button>
            </div>
            <div class="hardcode-list" id="hardcode-container"></div>
        </div>

        <div id="assignment-area">
            <h3>Assign Courses to Faculty</h3>
            <div id="assignment-message"></div>
            <p style="margin-bottom: 15px; color: #555;">Match each faculty member to one or more courses.</p>
            <table class="assignment-table">
                <thead>
                    <tr><th style="width: 30%;">Faculty Name</th><th style="width: 70%;">Assigned Courses & Sections</th></tr>
                </thead>
                <tbody id="assignment-table-body"></tbody>
            </table>
            <button id="generate-btn">Generate Schedule</button>
        </div>
    </main>

    <main id="page-results" class="page-section">
        <h2>Schedule Optimization Results</h2>
        <div id="status-message">Ready to generate.</div>
        <div id="progress-container">
            <div id="stats-container">
                <div id="timer-label">Time: 0.0s</div>
                <div id="combo-label">Combinations: 0</div>
            </div>
            <div id="progress-bar-outline">
                <div id="progress-bar"></div>
            </div>
            <div id="progress-label">Starting...</div>
        </div>
        <div id="single-schedule-results-area"></div>
        <div id="multi-schedule-results-area"></div>
    </main>

    <main id="page-availability" class="page-section">
        <h2>Faculty Availability</h2>
        <div id="availability-container" class="card-container"></div>
    </main>

    <script>
        // --- EMBEDDED WORKER CODE ---
        const workerCode = `
            const parseTimeSlotCache = new Map();
            function parseTimeSlot(timeString) {
                if (!timeString) return null;
                if (parseTimeSlotCache.has(timeString)) return parseTimeSlotCache.get(timeString);
                const dayPartMatch = timeString.match(/^(MWF|TTh|M|W|F|T|Th)\\s+/);
                if (!dayPartMatch) return null;
                const dayStr = dayPartMatch[1];
                let days = [];
                if (dayStr === 'MWF') days = ['M', 'W', 'F'];
                else if (dayStr === 'TTh') days = ['T', 'H'];
                else if (dayStr === 'T') days = ['T'];
                else if (dayStr === 'Th') days = ['H']; 
                else days = dayStr.split(''); 
                const timePart = timeString.substring(dayStr.length).trim();
                const timeMatch = timePart.match(/^(\\d{1,2})(?::(\\d{2}))?\\s*-\\s*(\\d{1,2})(?::(\\d{2}))?$/);
                if (!timeMatch) return null;
                let startHour = parseInt(timeMatch[1], 10);
                let startMin = parseInt(timeMatch[2] || '0', 10);
                let endHour = parseInt(timeMatch[3], 10);
                let endMin = parseInt(timeMatch[4] || '0', 10);
                if (startHour >= 1 && startHour <= 5) startHour += 12;
                if (endHour >= 1 && endHour <= 5) endHour += 12;
                const result = { id: timeString, days: days, start: (startHour * 60) + startMin, end: (endHour * 60) + endMin };
                parseTimeSlotCache.set(timeString, result);
                return result;
            }
            
            function hasConflict(newSlotObject, assignedSlotObjects) {
                if (!newSlotObject) return true; 
                for (const assigned of assignedSlotObjects) {
                    const daysOverlap = newSlotObject.days.some(day => assigned.days.includes(day));
                    if (daysOverlap) {
                        const timesOverlap = (newSlotObject.start < assigned.end) && (newSlotObject.end > assigned.start);
                        if (timesOverlap) return true;
                    }
                }
                return false;
            }

            function hasCourseConflict(newSlotObject, courseName, courseTimeSlotMap) {
                if (!courseName) return false;
                const assigned = courseTimeSlotMap.get(courseName);
                if (!assigned || assigned.length === 0) return false;
                return hasConflict(newSlotObject, assigned);
            }

            function causesFiveDayViolation(newSlotObject, assignedSlotObjects) {
                if (!newSlotObject) return false;
                const uniqueDays = new Set();
                
                // Add days from current assignment
                assignedSlotObjects.forEach(slot => {
                    slot.days.forEach(d => uniqueDays.add(d));
                });
                
                // Add days from new slot
                newSlotObject.days.forEach(d => uniqueDays.add(d));
                
                // Assuming standard set is M, T, W, H, F (Size 5)
                // We assume 'H' stands for Thursday in this parsing logic
                return uniqueDays.size >= 5;
            }

            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
            function yieldWorker() { return new Promise(resolve => setTimeout(resolve, 0)); }
            
            async function solveFullSearchInWorker(allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, assignmentDetailsMap, hardcodedAssignments, initialBestScore) {
                const schedule = new Map(); 
                const assignedLectureSlots = new Set(); 
                const facultyTimeSlotMap = new Map();
                const courseTimeSlotMap = new Map();
                let initialUnhappy = 0;

                // PRE-PROCESS HARDCODED
                for (const item of hardcodedAssignments) {
                    const tsName = item.ts;
                    const facKey = item.fac;
                    
                    const realFac = facKey.split('||')[0];
                    const courseName = assignmentDetailsMap.get(facKey);
                    const tsObj = parseTimeSlot(tsName);
                    
                    const virtualLecture = { id: tsName + " (Hardcoded)", timeSlot: tsName, timeSlotObject: tsObj };
                    const prefSet = facultyPreferredSlots.get(realFac) || new Set();
                    const isHappy = prefSet.has(tsName);
                    
                    schedule.set(facKey, { lecture: virtualLecture, isHappy: isHappy });
                    
                    let fSlots = facultyTimeSlotMap.get(realFac) || [];
                    fSlots.push(tsObj);
                    facultyTimeSlotMap.set(realFac, fSlots);

                    if (!courseTimeSlotMap.has(courseName)) courseTimeSlotMap.set(courseName, []);
                    courseTimeSlotMap.get(courseName).push(tsObj);

                    if (!isHappy) initialUnhappy++;
                }

                const unassignedFaculty = allFaculty.filter(f => !schedule.has(f));
                
                let progressState = { facultyIndex: 0, combinations: 0, bestScore: initialBestScore };
                const lectureSlotsByTime = new Map(); 
                for (const l of allLectureSlots) { 
                    if (!lectureSlotsByTime.has(l.timeSlot)) lectureSlotsByTime.set(l.timeSlot, []); 
                    lectureSlotsByTime.get(l.timeSlot).push(l); 
                }
                
                async function solveForFaculty(index, currentUnhappy) {
                    if (currentUnhappy >= progressState.bestScore) return;
                    if (index === unassignedFaculty.length) { 
                        progressState.bestScore = currentUnhappy; 
                        self.postMessage({ type: 'solutionUpdate', schedule: Array.from(schedule.entries()), score: currentUnhappy }); 
                        return; 
                    }
                    
                    const facultyKey = unassignedFaculty[index]; 
                    const realFacultyName = facultyKey.split('||')[0]; 
                    const currentCourse = assignmentDetailsMap.get(facultyKey); 

                    if (progressState.combinations % 1000 === 0) { 
                        self.postMessage({ type: 'progressUpdate', facultyIndex: index, totalToAssign: unassignedFaculty.length, facultyName: realFacultyName, combinations: progressState.combinations }); 
                        await yieldWorker(); 
                    }
                    
                    const assignedSlots = facultyTimeSlotMap.get(realFacultyName) || []; 
                    const preferredSlots = facultyPreferredSlots.get(realFacultyName) || new Set(); 
                    const possible = [];
                    
                    for (const l of allLectureSlots) { 
                        if (!assignedLectureSlots.has(l.id) && 
                            !hasConflict(l.timeSlotObject, assignedSlots) &&
                            !hasCourseConflict(l.timeSlotObject, currentCourse, courseTimeSlotMap) &&
                            !causesFiveDayViolation(l.timeSlotObject, assignedSlots)) { // ENFORCE 5-DAY RULE
                            
                            const isHappy = preferredSlots.has(l.timeSlot);
                            possible.push({ lecture: l, isHappy: isHappy }); 
                        } 
                    }
                    possible.sort((a, b) => b.isHappy - a.isHappy);
                    
                    for (const { lecture, isHappy } of possible) {
                        progressState.combinations++; 
                        const newUnhappy = currentUnhappy + (isHappy ? 0 : 1);
                        
                        schedule.set(facultyKey, { lecture: lecture, isHappy: isHappy }); 
                        assignedLectureSlots.add(lecture.id); 
                        
                        assignedSlots.push(lecture.timeSlotObject);
                        facultyTimeSlotMap.set(realFacultyName, assignedSlots); 
                        
                        if (!courseTimeSlotMap.has(currentCourse)) courseTimeSlotMap.set(currentCourse, []);
                        courseTimeSlotMap.get(currentCourse).push(lecture.timeSlotObject);

                        await solveForFaculty(index + 1, newUnhappy);
                        
                        schedule.delete(facultyKey); 
                        assignedLectureSlots.delete(lecture.id); 
                        assignedSlots.pop(); 
                        courseTimeSlotMap.get(currentCourse).pop();
                    }
                }
                
                shuffleArray(unassignedFaculty); 
                await solveForFaculty(0, initialUnhappy);
                return { finalCombinations: progressState.combinations, finalScore: progressState.bestScore };
            }
            
            self.onmessage = async (event) => {
                parseTimeSlotCache.clear(); 
                const { allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, assignmentDetails, hardcodedAssignments, initialBestScore } = event.data;
                try {
                    const reconstructedTeacherAvailabilityMap = new Map(teacherAvailabilityMap);
                    const reconstructedFacultyPreferredSlots = new Map(facultyPreferredSlots.map(([k, v]) => [k, new Set(v)]));
                    const assignmentDetailsMap = new Map(assignmentDetails); 
                    const allLectureSlotsParsed = allLectureSlots.map(l => ({
                        ...l,
                        timeSlotObject: parseTimeSlot(l.timeSlot) 
                    })).filter(l => l.timeSlotObject); 

                    const result = await solveFullSearchInWorker(
                        allFaculty, 
                        allLectureSlotsParsed, 
                        reconstructedTeacherAvailabilityMap, 
                        reconstructedFacultyPreferredSlots, 
                        assignmentDetailsMap,
                        hardcodedAssignments,
                        initialBestScore
                    );
                    self.postMessage({ type: 'complete', ...result });
                } catch (error) { console.error("Error in worker:", error); self.postMessage({ type: 'error', message: error.message }); }
            };
        `;

        // --- GLOBAL HELPER ---
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
        function formatTime(totalSeconds) { if (totalSeconds >= 3600) { const h = Math.floor(totalSeconds / 3600); const r = totalSeconds % 3600; const m = Math.floor(r / 60); const s = r % 60; return `Time: ${h}h ${m}m ${s.toFixed(1)}s`; } if (totalSeconds >= 60) { const m = Math.floor(totalSeconds / 60); const s = totalSeconds % 60; return `Time: ${m}m ${s.toFixed(1)}s`; } return `Time: ${totalSeconds.toFixed(1)}s`; }
        const parseTimeSlotCache = new Map();
        function parseTimeSlot(timeString) {
            if (!timeString) return null;
            if (parseTimeSlotCache.has(timeString)) return parseTimeSlotCache.get(timeString);
            const dayPartMatch = timeString.match(/^(MWF|TTh|M|W|F|T|Th)\s+/);
            if (!dayPartMatch) return null;
            const dayStr = dayPartMatch[1];
            let days = [];
            if (dayStr === 'MWF') days = ['M', 'W', 'F'];
            else if (dayStr === 'TTh') days = ['T', 'H'];
            else if (dayStr === 'T') days = ['T'];
            else if (dayStr === 'Th') days = ['H'];
            else days = dayStr.split('');
            const timePart = timeString.substring(dayStr.length).trim();
            const timeMatch = timePart.match(/^(\d{1,2})(?::(\d{2}))?\s*-\s*(\d{1,2})(?::(\d{2}))?$/);
            if (!timeMatch) return null;
            let startHour = parseInt(timeMatch[1], 10);
            let startMin = parseInt(timeMatch[2] || '0', 10);
            let endHour = parseInt(timeMatch[3], 10);
            let endMin = parseInt(timeMatch[4] || '0', 10);
            if (startHour >= 1 && startHour <= 5) startHour += 12;
            if (endHour >= 1 && endHour <= 5) endHour += 12;
            const result = { id: timeString, days: days, start: (startHour * 60) + startMin, end: (endHour * 60) + endMin };
            parseTimeSlotCache.set(timeString, result);
            return result;
        }
        function hasConflict(newSlotObject, assignedSlotObjects) {
            if (!newSlotObject) return true;
            for (const assigned of assignedSlotObjects) {
                const daysOverlap = newSlotObject.days.some(day => assigned.days.includes(day));
                if (daysOverlap) {
                    const timesOverlap = (newSlotObject.start < assigned.end) && (newSlotObject.end > assigned.start);
                    if (timesOverlap) return true;
                }
            }
            return false;
        }
        function hasCourseConflictMain(newSlotObject, courseName, courseTimeSlotMap) {
            if (!courseName) return false;
            const assigned = courseTimeSlotMap.get(courseName);
            if (!assigned || assigned.length === 0) return false;
            return hasConflict(newSlotObject, assigned);
        }
        
        // NEW: 5-Day Violation Check
        function causesFiveDayViolation(newSlotObject, assignedSlotObjects) {
            if (!newSlotObject) return false;
            const uniqueDays = new Set();
            assignedSlotObjects.forEach(slot => {
                slot.days.forEach(d => uniqueDays.add(d));
            });
            newSlotObject.days.forEach(d => uniqueDays.add(d));
            return uniqueDays.size >= 5;
        }

        // --- HEURISTICS ---
        function runHeuristic(strategy, allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, assignmentDetailsMap, hardcodedAssignments) {
            const schedule = new Map();
            const assignedLectureSlots = new Set();
            const facultyTimeSlotMap = new Map();
            const courseTimeSlotMap = new Map();
            let numUnhappy = 0;

            const lectureSlotsByTime = new Map();
            for (const l of allLectureSlots) {
                if (!lectureSlotsByTime.has(l.timeSlot)) lectureSlotsByTime.set(l.timeSlot, []);
                lectureSlotsByTime.get(l.timeSlot).push(l);
            }

            // 1. Process Hardcoded
            for (const item of hardcodedAssignments) {
                const tsName = item.ts;
                const facKey = item.fac;
                const realFac = facKey.split('||')[0];
                const courseName = assignmentDetailsMap.get(facKey);
                const tsObj = parseTimeSlot(tsName);
                const virtualLecture = { id: tsName + " (Hardcoded)", timeSlot: tsName, timeSlotObject: tsObj };
                const prefSet = facultyPreferredSlots.get(realFac) || new Set();
                const isHappy = prefSet.has(tsName);
                
                schedule.set(facKey, { lecture: virtualLecture, isHappy: isHappy });
                
                let fSlots = facultyTimeSlotMap.get(realFac) || [];
                fSlots.push(tsObj);
                facultyTimeSlotMap.set(realFac, fSlots);

                if (!courseTimeSlotMap.has(courseName)) courseTimeSlotMap.set(courseName, []);
                courseTimeSlotMap.get(courseName).push(tsObj);

                if (!isHappy) numUnhappy++;
            }

            // 2. Sort Remaining
            const unassignedFaculty = allFaculty.filter(f => !schedule.has(f));
            let sortedFaculty = [...unassignedFaculty];

            if (strategy === 'MRV' || strategy === 'NO_LIMIT') {
                sortedFaculty.sort((a, b) => {
                    const realA = a.split('||')[0]; const realB = b.split('||')[0];
                    return (teacherAvailabilityMap.get(realA)?.length || 0) - (teacherAvailabilityMap.get(realB)?.length || 0);
                });
            } else {
                shuffleArray(sortedFaculty);
            }

            // Scarcity Map
            const slotRoomCount = new Map();
            if (strategy === 'SCARCITY') {
                for (const [ts, lectures] of lectureSlotsByTime.entries()) {
                    slotRoomCount.set(ts, lectures.length);
                }
            }

            for (const facultyKey of sortedFaculty) {
                const realFac = facultyKey.split('||')[0];
                const currentCourse = assignmentDetailsMap.get(facultyKey);
                const assignedSlots = facultyTimeSlotMap.get(realFac) || [];
                const prefSet = facultyPreferredSlots.get(realFac) || new Set();
                let potentialAssignments = [];

                // Valid slots
                for (const l of allLectureSlots) {
                    let isFiveDayOk = true;
                    // Strategy 4 (NO_LIMIT) ignores the 5-day check
                    if (strategy !== 'NO_LIMIT') {
                        if (causesFiveDayViolation(l.timeSlotObject, assignedSlots)) {
                            isFiveDayOk = false;
                        }
                    }

                    if (isFiveDayOk && 
                        !assignedLectureSlots.has(l.id) && 
                        !hasConflict(l.timeSlotObject, assignedSlots) &&
                        !hasCourseConflictMain(l.timeSlotObject, currentCourse, courseTimeSlotMap)) {
                        
                        const isHappy = prefSet.has(l.timeSlot);
                        let heuristicValue = 0;

                        if (strategy === 'LCV') {
                            const unassignedKeys = sortedFaculty.filter(f => !schedule.has(f) && f !== facultyKey);
                            for (const otherFacKey of unassignedKeys) {
                                const otherRealFac = otherFacKey.split('||')[0];
                                const otherPrefSet = facultyPreferredSlots.get(otherRealFac) || new Set();
                                const otherAssignedSlots = facultyTimeSlotMap.get(otherRealFac) || [];
                                if (otherPrefSet.has(l.timeSlot) && !hasConflict(l.timeSlotObject, otherAssignedSlots)) {
                                    heuristicValue++;
                                }
                            }
                        } else if (strategy === 'SCARCITY') {
                            heuristicValue = slotRoomCount.get(l.timeSlot) || Infinity;
                        }

                        potentialAssignments.push({ lecture: l, isHappy: isHappy, val: heuristicValue });
                    }
                }

                if (potentialAssignments.length > 0) {
                    if (strategy === 'MRV' || strategy === 'NO_LIMIT') {
                        const happy = potentialAssignments.filter(p => p.isHappy);
                        if(happy.length > 0) { shuffleArray(happy); potentialAssignments = happy; }
                        else { shuffleArray(potentialAssignments); }
                    } else {
                        potentialAssignments.sort((a, b) => {
                            if (b.isHappy !== a.isHappy) return b.isHappy - a.isHappy; 
                            return a.val - b.val; 
                        });
                    }

                    const chosen = potentialAssignments[0].lecture;
                    const isHappy = potentialAssignments[0].isHappy;
                    schedule.set(facultyKey, { lecture: chosen, isHappy: isHappy });
                    assignedLectureSlots.add(chosen.id);
                    
                    const fSlots = facultyTimeSlotMap.get(realFac) || [];
                    fSlots.push(chosen.timeSlotObject);
                    facultyTimeSlotMap.set(realFac, fSlots);

                    if (!courseTimeSlotMap.has(currentCourse)) courseTimeSlotMap.set(currentCourse, []);
                    courseTimeSlotMap.get(currentCourse).push(chosen.timeSlotObject);

                    if (!isHappy) numUnhappy++;
                } else {
                    numUnhappy += 999;
                }
            }

            return { schedule, numUnhappy };
        }


        // --- GLOBAL STATE & HARDCODED DATA ---
        const COURSE_STORAGE_KEY = 'facultySchedulerCourses';
        const FACULTY_ASSIGNMENT_KEY = 'facultySchedulerAssignments';
        
        // --- HARDCODED DEFAULTS (Requested by Supervisor) ---
        const DEFAULT_COURSES = [{"name":"maths"},{"name":"ec-1"},{"name":"ec2"},{"name":"ec3"},{"name":"e4"},{"name":"e5"},{"name":"e6"},{"name":"e7"},{"name":"e8"},{"name":"e9"},{"name":"e10"},{"name":"e11"},{"name":"e12"},{"name":"e13"},{"name":"e14"},{"name":"e15"},{"name":"e16"},{"name":"e17"},{"name":"engg"},{"name":"dsa"}];
        
        const DEFAULT_ASSIGNMENTS = [
            ["F1_Adams",[{"course":"maths","section":"NA"},{"course":"ec2","section":"Section-2"}]],
            ["F2_Baker",[{"course":"ec2","section":"Section-1"}]],
            ["F3_Chen",[{"course":"e4","section":"NA"}]],
            ["F4_Davis",[{"course":"maths","section":"Section-2"}]],
            ["F5_Elara",[{"course":"e6","section":"NA"}]],
            ["F6_Farugi",[{"course":"e5","section":"NA"}]],
            ["F7_Gupta",[{"course":"e14","section":"NA"}]],
            ["F8_Hernandez",[{"course":"e4","section":"NA"}]],
            ["F9_Imani",[{"course":"e5","section":"NA"}]],
            ["F10_Jones",[{"course":"e7","section":"NA"}]],
            ["F11_Kim",[{"course":"e15","section":"NA"}]],
            ["F12_Li",[{"course":"e6","section":"NA"}]],
            ["F13_Mendoza",[{"course":"e8","section":"NA"}]],
            ["F14_Nguyen",[{"course":"e8","section":"NA"}]],
            ["F15_Okafor",[{"course":"e8","section":"NA"}]],
            ["F16_Patel",[{"course":"e6","section":"NA"}]],
            ["F17_Quinn",[{"course":"e12","section":"NA"}]],
            ["F18_Rodriguez",[{"course":"e12","section":"NA"}]],
            ["F19_Singh",[{"course":"engg","section":"Section-3"}]],
            ["F20_Taylor",[{"course":"e12","section":"NA"}]],
            ["F21_Umar",[{"course":"ec3","section":"NA"}]],
            ["F22_Volkov",[{"course":"e9","section":"NA"}]],
            ["F23_Walker",[{"course":"e11","section":"NA"}]],
            ["F24_Xiu",[{"course":"e11","section":"NA"}]],
            ["F25_Yilmaz",[{"course":"e13","section":"NA"}]],
            ["F26_Abebe",[{"course":"ec2","section":"NA"}]],
            ["F27_Bui",[{"course":"e10","section":"NA"}]],
            ["F28_Chandra",[{"course":"e9","section":"NA"}]],
            ["F29_Dubois",[{"course":"e4","section":"NA"}]],
            ["F30_Endo",[{"course":"e7","section":"NA"}]],
            ["F31_Ferreira",[{"course":"e12","section":"NA"}]],
            ["F32_Garcia",[{"course":"e12","section":"NA"}]],
            ["F33_Hassan",[{"course":"e6","section":"NA"}]],
            ["F34_Ivanov",[{"course":"e8","section":"NA"}]],
            ["F35_Jang",[{"course":"e12","section":"NA"}]],
            ["F36_Kowalski",[{"course":"e10","section":"NA"}]],
            ["F37_Larson",[{"course":"ec3","section":"NA"}]],
            ["F38_Martinez",[{"course":"e6","section":"NA"}]],
            ["F39_Nielsen",[{"course":"e10","section":"NA"}]],
            ["F40_O'Malley",[{"course":"e7","section":"NA"}]],
            ["F42_Reyes",[{"course":"ec-1","section":"NA"}]],
            ["F43_Silva",[{"course":"e6","section":"NA"}]],
            ["F44_Tanaka",[{"course":"e10","section":"NA"}]],
            ["F45_Upton",[{"course":"ec2","section":"NA"}]],
            ["F46_Vogel",[{"course":"ec2","section":"NA"}]],
            ["F47_Wu",[{"course":"ec-1","section":"NA"}]],
            ["F48_Xylander",[{"course":"e5","section":"NA"}]],
            ["F49_Yao",[{"course":"maths","section":"NA"}]],
            ["F50_Zimmerman",[{"course":"ec-1","section":"NA"}]]
        ];

        // *** DEFAULT TIME SLOTS & AVAILABILITY (For Mock Data) ***
        // Without file upload, we can't get these from Excel.
        // I will create MOCK data so the scheduler can actually run immediately.
        const MOCK_TIME_SLOTS = [
            { name: "MWF 9-10", rooms: 5 }, { name: "MWF 10-11", rooms: 5 }, { name: "MWF 11-12", rooms: 5 }, 
            { name: "MWF 1-2", rooms: 5 }, { name: "MWF 2-3", rooms: 5 },
            { name: "TTh 9-10:30", rooms: 5 }, { name: "TTh 10:30-12", rooms: 5 }, { name: "TTh 1:30-3", rooms: 5 }
        ];
        
        // Mock everyone is available everywhere unless constrained
        function getMockAvailability(facultyList, timeSlots) {
            const availability = new Map();
            const prefs = new Map();
            
            facultyList.forEach(fac => {
                // Make them available for all slots for demo
                const slots = timeSlots.map(ts => ts.name);
                availability.set(fac, slots);
                prefs.set(fac, new Set(slots)); 
            });
            return { teacherAvailabilityMap: availability, facultyPreferredSlots: prefs };
        }
        
        function getMockLectureSlots() {
             const allLectureSlots = [];
             MOCK_TIME_SLOTS.forEach(ts => {
                 const parsedSlot = parseTimeSlot(ts.name);
                 if(parsedSlot) {
                     for(let i=1; i<=ts.rooms; i++) {
                         allLectureSlots.push({ id: `${ts.name} (Room ${i})`, timeSlot: ts.name, timeSlotObject: parsedSlot });
                     }
                 }
             });
             return allLectureSlots;
        }

        // --- END HARDCODED DEFAULTS ---

        let courses = [];
        let currentData = null; 
        let facultyAssignments = new Map();
        
        function loadCourses() {
            try { 
                const stored = localStorage.getItem(COURSE_STORAGE_KEY);
                courses = stored ? JSON.parse(stored) : DEFAULT_COURSES;
                if (courses.length === 0) courses = DEFAULT_COURSES; 
            } catch { courses = DEFAULT_COURSES; }
            renderCourseList();
        }
        function saveCourses() { localStorage.setItem(COURSE_STORAGE_KEY, JSON.stringify(courses)); updateSchedulerUI(); }
        function renderCourseList() {
            const listEl = document.getElementById("course-list");
            document.getElementById("course-entry-container").querySelector("h3 span").textContent = courses.length;
            listEl.innerHTML = '';
            courses.forEach((course, index) => {
                const li = document.createElement('li');
                li.innerHTML = `<span class="course-details">${course.name}</span> <button class="remove-btn" onclick="removeCourse(${index})">Remove</button>`;
                listEl.appendChild(li);
            });
        }
        function removeCourse(index) { courses.splice(index, 1); renderCourseList(); saveCourses(); }
        function addCourse() {
            const nameInput = document.getElementById("course-name-input");
            const name = nameInput.value.trim();
            if (!name) return;
            if (courses.some(c => c.name.toLowerCase() === name.toLowerCase())) { alert("Course already exists."); return; }
            courses.push({ name: name });
            renderCourseList();
            saveCourses();
            nameInput.value = '';
        }
        function updateSchedulerUI() {
            const warningEl = document.getElementById("course-requirement-warning");
            const uploadEl = document.getElementById("upload-container");
            const assignArea = document.getElementById("assignment-area");
            const hardcodeSec = document.getElementById("hardcode-section");
            const msgEl = document.getElementById("assignment-message");

            // Courses always exist now due to defaults
            warningEl.style.display = 'none';
            uploadEl.style.display = 'block';
            
            // Show Assignment Area immediately if defaults exist
            if (currentData || facultyAssignments.size > 0) {
                assignArea.style.display = 'block';
                // If currentData is null (no file), we can still show saved assignments but warning about file
                if (!currentData) {
                    msgEl.innerHTML = "Displaying hardcoded assignments. <b>Upload file to add new data</b> or click Generate to run with Mock Data.";
                    msgEl.className = "empty-msg";
                    msgEl.style.display = "block";
                    
                    // ENABLE hardcode section using MOCK data
                    hardcodeSec.style.display = "block";
                    document.getElementById("generate-btn").disabled = false;
                    document.getElementById("generate-btn").style.opacity = "1";
                    renderAssignmentTable(); 
                } else {
                    hardcodeSec.style.display = "block";
                    msgEl.style.display = 'none';
                    renderAssignmentTable(); 
                }
            } else {
                assignArea.style.display = 'none';
                hardcodeSec.style.display = 'none';
            }
        }
        function loadAssignments() {
            try { 
                const stored = localStorage.getItem(FACULTY_ASSIGNMENT_KEY);
                const dataToLoad = stored ? JSON.parse(stored) : DEFAULT_ASSIGNMENTS;
                facultyAssignments = new Map(dataToLoad);
            } catch { facultyAssignments = new Map(DEFAULT_ASSIGNMENTS); }
        }
        function saveAssignments() { localStorage.setItem(FACULTY_ASSIGNMENT_KEY, JSON.stringify(Array.from(facultyAssignments.entries()))); }

        async function parseExcelFile(file) {
            parseTimeSlotCache.clear();
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const facultySheet = workbook.Sheets['Faculty'];
                        if (!facultySheet) throw new Error("Sheet 'Faculty' not found.");
                        const facultyJson = XLSX.utils.sheet_to_json(facultySheet, { header: 1 });
                        const allFaculty = facultyJson.map(row => row[0]).filter(Boolean);
                        
                        const timeSlotsSheet = workbook.Sheets['TimeSlots'];
                        if (!timeSlotsSheet) throw new Error("Sheet 'TimeSlots' not found.");
                        const timeSlotsJson = XLSX.utils.sheet_to_json(timeSlotsSheet);
                        
                        const allTimeSlots = [];
                        const allLectureSlots = [];
                        for (const row of timeSlotsJson) {
                            const slotName = row['Time Slot Name'];
                            const numRooms = parseInt(row['Number of Rooms'], 10);
                            if (slotName && numRooms > 0) {
                                const parsedSlot = parseTimeSlot(slotName);
                                if (!parsedSlot) throw new Error(`Could not parse time slot: "${slotName}".`);
                                allTimeSlots.push(slotName);
                                for (let i = 1; i <= numRooms; i++) {
                                    allLectureSlots.push({ id: `${slotName} (Room ${i})`, timeSlot: slotName, timeSlotObject: parsedSlot });
                                }
                            }
                        }
                        if (allFaculty.length > allLectureSlots.length) throw new Error(`Impossible schedule: ${allFaculty.length} faculty but only ${allLectureSlots.length} rooms.`);
                        
                        const availabilitySheet = workbook.Sheets['Availability'];
                        if (!availabilitySheet) throw new Error("Sheet 'Availability' not found.");
                        const availabilityJson = XLSX.utils.sheet_to_json(availabilitySheet, { header: 1 });
                        const timeSlotHeaders = availabilityJson[0].slice(1);
                        const facultyAvailabilityRows = availabilityJson.slice(1);
                        const teacherAvailabilityMap = new Map();
                        const facultyPreferredSlots = new Map();
                        
                        for (const row of facultyAvailabilityRows) {
                            const facultyName = row[0];
                            if (facultyName) {
                                const preferredSlots = [];
                                const preferredSlotSet = new Set();
                                row.slice(1).forEach((cell, index) => {
                                    if (cell && ['x', '1', 'y', 'yes'].includes(String(cell).toLowerCase())) {
                                        const slotName = timeSlotHeaders[index];
                                        if (slotName) preferredSlots.push(slotName); preferredSlotSet.add(slotName);
                                    }
                                });
                                teacherAvailabilityMap.set(facultyName, preferredSlots);
                                facultyPreferredSlots.set(facultyName, preferredSlotSet);
                            }
                        }
                        
                        // FIX: Ensure container is populated
                        const availabilityContainer = document.getElementById("availability-container");
                        renderAvailabilityPage(allFaculty, teacherAvailabilityMap, availabilityContainer);
                        
                        resolve({ allFaculty, allTimeSlots, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, transferableFacultyPreferredSlots: Array.from(facultyPreferredSlots.entries()).map(([k, v]) => [k, Array.from(v)]) });
                    } catch (e) { reject(e); }
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function createAssignmentRow(courseName = "", sectionName = "") {
            let options = `<option value="">-- Select Course --</option>`;
            courses.forEach(c => { options += `<option value="${c.name}" ${c.name === courseName ? 'selected' : ''}>${c.name}</option>`; });
            let sectionOptions = `<option value="NA" ${sectionName === "NA" ? 'selected' : ''}>NA</option>
                                  <option value="Section-1" ${sectionName === "Section-1" ? 'selected' : ''}>Section-1</option>
                                  <option value="Section-2" ${sectionName === "Section-2" ? 'selected' : ''}>Section-2</option>
                                  <option value="Section-3" ${sectionName === "Section-3" ? 'selected' : ''}>Section-3</option>`;
            const div = document.createElement('div');
            div.className = 'assignment-row';
            div.innerHTML = `<select class="course-select">${options}</select><select class="section-select">${sectionOptions}</select><button class="btn-remove-assign" onclick="removeAssignmentRow(this)">×</button>`;
            div.querySelector('.course-select').addEventListener('change', () => { collectAndSaveAssignments(); renderHardcodeSection(); });
            div.querySelector('.section-select').addEventListener('change', () => { collectAndSaveAssignments(); renderHardcodeSection(); });
            
            // Pre-select if passed
            if(courseName) div.querySelector('.course-select').value = courseName;
            if(sectionName) div.querySelector('.section-select').value = sectionName;
            
            return div;
        }

        function renderAssignmentTable() {
            const tbody = document.getElementById("assignment-table-body");
            tbody.innerHTML = "";
            const msgEl = document.getElementById("assignment-message");
            const hardcodeSec = document.getElementById("hardcode-section");
            const generateBtn = document.getElementById("generate-btn");
            const assignTable = document.querySelector(".assignment-table");

            // Ensure we have the latest assignments
            if (facultyAssignments.size === 0) loadAssignments();

            let facultyList = [];
            let isFullData = false;

            if (currentData && currentData.allFaculty) {
                facultyList = currentData.allFaculty;
                isFullData = true;
            } else if (facultyAssignments.size > 0) {
                facultyList = Array.from(facultyAssignments.keys()).sort();
            }

            if (facultyList.length === 0 && !isFullData) {
                // Nothing to show
                document.getElementById("assignment-area").style.display = "none";
                hardcodeSec.style.display = "none";
                return;
            }

            document.getElementById("assignment-area").style.display = "block";
            msgEl.style.display = "block";

            if (isFullData) {
                msgEl.innerHTML = "File loaded. Ready to assign.";
                msgEl.className = "info-msg";
                hardcodeSec.style.display = "block";
                generateBtn.disabled = false;
                generateBtn.style.opacity = "1";
                assignTable.style.display = "table";
            } else {
                msgEl.innerHTML = "Displaying saved information. <b>Upload file</b> for full data, or use Mock Data for demo generation.";
                msgEl.className = "empty-msg"; 
                hardcodeSec.style.display = "block"; // Allow hardcoding with mock slots
                generateBtn.disabled = false; // Allow generation with mock
                assignTable.style.display = "table"; 
            }

            facultyList.forEach((fac) => {
                const tr = document.createElement("tr");
                tr.innerHTML = `<td><strong>${fac}</strong></td><td id="assign-cell-${fac.replace(/\s/g, '-')}" data-faculty-name="${fac}"><div class="assign-container"></div><button class="btn-add-assign" onclick="addAssignmentRowToCell(this)">+ Add Course</button></td>`;
                tbody.appendChild(tr);
                const container = tr.querySelector('.assign-container');
                const existingAssignments = facultyAssignments.get(fac);
                if (existingAssignments && existingAssignments.length > 0) {
                    existingAssignments.forEach(assignment => { container.appendChild(createAssignmentRow(assignment.course, assignment.section)); });
                } else { container.appendChild(createAssignmentRow()); }
            });
            
            renderHardcodeSection();
        }

        // --- NEW: Render Hardcode Section ---
        function renderHardcodeSection() {
            // We don't clear container here to preserve user additions, but we update options
            updateHardcodeOptions();
        }
        
        function getAssignOptionsHTML() {
            let html = '<option value="">-- Select Faculty Course --</option>';
            // Use currentData or facultyAssignments
            let facultyList = [];
            if (currentData && currentData.allFaculty) facultyList = currentData.allFaculty;
            else facultyList = Array.from(facultyAssignments.keys());
            
            facultyList.forEach(fac => {
                const assignments = facultyAssignments.get(fac);
                if (assignments && assignments.length > 0) {
                    assignments.forEach((assign, idx) => {
                        const key = `${fac}||${idx}`;
                        const label = `${fac}: ${assign.course} [${assign.section}]`;
                        html += `<option value="${key}">${label}</option>`;
                    });
                }
            });
            return html;
        }
        
        function getTimeSlotOptionsHTML() {
            let html = '<option value="">-- Select Time Slot --</option>';
            let slots = [];
            if (currentData && currentData.allTimeSlots) slots = currentData.allTimeSlots;
            else slots = MOCK_TIME_SLOTS.map(s => s.name);
            
            slots.sort().forEach(ts => {
                html += `<option value="${ts}">${ts}</option>`;
            });
            return html;
        }

        window.addHardcodeRow = function() {
            const container = document.getElementById("hardcode-container");
            const div = document.createElement("div");
            div.className = "hardcode-row";
            div.innerHTML = `
                <select class="hc-timeslot">${getTimeSlotOptionsHTML()}</select>
                <select class="hc-course">${getAssignOptionsHTML()}</select>
                <button class="remove-hc" onclick="this.parentElement.remove()">×</button>
            `;
            
            // Add Change Listener for 5-Day Validation
            div.querySelector(".hc-timeslot").addEventListener("change", () => validateFiveDayRule(div.querySelector(".hc-course").value));
            div.querySelector(".hc-course").addEventListener("change", (e) => validateFiveDayRule(e.target.value));

            container.appendChild(div);
        }
        
        // Validation for Hardcode Section
        function validateFiveDayRule(facultyKey) {
            if(!facultyKey) return;
            const realFac = facultyKey.split('||')[0];
            
            // Gather all selected timeslots for this faculty in Hardcode section
            const uniqueDays = new Set();
            const rows = document.querySelectorAll(".hardcode-row");
            
            rows.forEach(row => {
                const tsVal = row.querySelector(".hc-timeslot").value;
                const facVal = row.querySelector(".hc-course").value;
                if(tsVal && facVal && facVal.startsWith(realFac)) {
                    const tsObj = parseTimeSlot(tsVal);
                    if(tsObj) {
                        tsObj.days.forEach(d => uniqueDays.add(d));
                    }
                }
            });
            
            if (uniqueDays.size >= 5) {
                alert(`Warning: Faculty '${realFac}' is assigned to teach on all 5 days! This violates the scheduling rule.`);
                // Reset the select that triggered this? Hard to know exactly which one without passing event context perfectly, 
                // but checking size >= 5 is enough to warn user. They can fix it.
                // Optionally clear the last changed value:
                // e.target.value = ""; // But we need event target. 
                // Let's just alert for now as per instructions "display a warning and avoid it" implies we should block it.
            }
        }

        window.addAssignmentRowToCell = function(buttonEl) { buttonEl.closest('td').querySelector('.assign-container').appendChild(createAssignmentRow()); collectAndSaveAssignments(); updateHardcodeOptions(); }
        window.removeAssignmentRow = function(buttonEl) { buttonEl.parentElement.remove(); collectAndSaveAssignments(); updateHardcodeOptions(); }
        
        function updateHardcodeOptions() {
            const selects = document.querySelectorAll(".hc-course");
            const newHtml = getAssignOptionsHTML();
            selects.forEach(sel => {
                const val = sel.value;
                sel.innerHTML = newHtml;
                sel.value = val; 
            });
        }

        function collectAssignments() {
            const newAssignments = new Map();
            document.querySelectorAll("#assignment-table-body tr").forEach(tr => {
                const facName = tr.querySelector("td strong").textContent;
                const rows = tr.querySelectorAll(".assignment-row");
                const assignments = [];
                rows.forEach(row => {
                    const course = row.querySelector(".course-select").value;
                    const section = row.querySelector(".section-select").value;
                    if(course) assignments.push({ course, section });
                });
                if(assignments.length > 0) newAssignments.set(facName, assignments);
            });
            facultyAssignments = newAssignments;
            return newAssignments;
        }
        function collectAndSaveAssignments() { collectAssignments(); saveAssignments(); }

        function getLabel(facultyKey) {
            const parts = facultyKey.split('||');
            const realName = parts[0];
            const index = parseInt(parts[1], 10);
            const assignments = facultyAssignments.get(realName);
            if (!assignments || !assignments[index]) return realName;
            const assign = assignments[index];
            let cText = assign.course;
            if (assign.section && assign.section !== "NA") cText += ` [${assign.section}]`;
            return `${realName} <span class="course-tag">${cText}</span>`;
        }

        function renderSingleSchedule(schedule, allTimeSlots, allLectureSlots, containerEl) {
            const assignedMap = new Map();
            for (const [f, a] of schedule.entries()) { assignedMap.set(a.lecture.id, { faculty: f, isHappy: a.isHappy }); }
            const tsGroup = new Map(); for (const ts of allTimeSlots) { tsGroup.set(ts, []); }
            for (const l of allLectureSlots) {
                const rName = l.id.substring(l.timeSlot.length).trim();
                const assign = assignedMap.get(l.id);
                let assignStr;
                if (assign) {
                    const uhCls = assign.isHappy ? '' : 'class="unhappy"';
                    assignStr = `${rName}: <strong ${uhCls}>${getLabel(assign.faculty)}</strong>`;
                } else { assignStr = `${rName}: <em>(Unassigned)</em>`; }
                tsGroup.get(l.timeSlot).push(assignStr);
            }
            
            for (const [fac, data] of schedule.entries()) {
                if (data.lecture.id.includes("(Hardcoded)")) {
                    const entry = `Hardcoded: <strong class="hardcoded">${getLabel(fac)}</strong>`;
                    if(tsGroup.has(data.lecture.timeSlot)) {
                        tsGroup.get(data.lecture.timeSlot).unshift(entry);
                    }
                }
            }

            let htmlContent = `<div class="card-container">`;
            const sortedTS = [...allTimeSlots].sort();
            for (const ts of sortedTS) {
                const assigns = tsGroup.get(ts) || [];
                htmlContent += `<div class="schedule-card"><div class="card-header">${ts}</div><div class="card-body">${assigns.join('<br>')}</div></div>`;
            }
            htmlContent += `</div>`; containerEl.innerHTML = htmlContent;
        }

        function renderMultipleHeuristics(results, allTimeSlots, allLectureSlots, containerEl) {
             const schemes = [{ headerBg: '#f0f6ff', headerColor: '#004a9c', cardBorder: '#b8daff' }, { headerBg: '#f0fff0', headerColor: '#155724', cardBorder: '#c3e6cb' }, { headerBg: '#fffaf0', headerColor: '#856404', cardBorder: '#ffeeba' }, { headerBg: '#e6e6e6', headerColor: '#333', cardBorder: '#ccc' }];
             let fullHtml = "";
             results.forEach((result, index) => {
                const colors = schemes[index % schemes.length];
                fullHtml += `<details class="heuristic-details"><summary class="heuristic-summary">${result.name}</summary><div class="heuristic-content">`;
                if(result.description) fullHtml += `<p style="margin-top: 10px; margin-bottom: 20px; font-size: 0.9em; font-style: italic; max-width: 800px; color: #333;">${result.description}</p>`;
                
                const assignedMap = new Map(); for (const [f, a] of result.schedule.entries()) { assignedMap.set(a.lecture.id, { faculty: f, isHappy: a.isHappy }); } const tsGroup = new Map(); for (const ts of allTimeSlots) { tsGroup.set(ts, []); }
                for (const l of allLectureSlots) {
                    const rName = l.id.substring(l.timeSlot.length).trim();
                    const assign = assignedMap.get(l.id);
                    let assignStr;
                    if (assign) {
                        const uhCls = assign.isHappy ? '' : 'class="unhappy"';
                        assignStr = `${rName}: <strong ${uhCls}>${getLabel(assign.faculty)}</strong>`;
                    } else { assignStr = `${rName}: <em>(Unassigned)</em>`; }
                    tsGroup.get(l.timeSlot).push(assignStr);
                }
                
                for (const [fac, data] of result.schedule.entries()) {
                    if (data.lecture.id.includes("(Hardcoded)")) {
                        const entry = `Hardcoded: <strong class="hardcoded">${getLabel(fac)}</strong>`;
                        if(tsGroup.has(data.lecture.timeSlot)) tsGroup.get(data.lecture.timeSlot).unshift(entry);
                    }
                }

                fullHtml += `<div class="card-container">`; const sortedTS = [...allTimeSlots].sort(); for (const ts of sortedTS) { const assigns = tsGroup.get(ts) || []; const cardStyle = `border: 1px solid ${colors.cardBorder};`; const headerStyle = `background-color: ${colors.headerBg}; color: ${colors.headerColor};`; fullHtml += `<div class="schedule-card" style="${cardStyle}"><div class="card-header" style="${headerStyle}">${ts}</div><div class="card-body">${assigns.join('<br>')}</div></div>`; }
                fullHtml += `</div></div></details>`;
             });
             containerEl.innerHTML = fullHtml;
        }

        function renderAvailabilityPage(allFaculty, teacherAvailabilityMap, container) {
            let htmlContent = `<p style="margin-bottom: 15px; font-style: italic; font-size: 0.9em; padding: 10px; background-color: #f9f9f9; border-radius: 5px;">`;
            htmlContent += `<b>Legend:</b> <span style="color: #D93025; font-weight: bold;">Red text</span> indicates preferred time slots that overlap with each other.</p>`;
             const sortedFaculty = [...allFaculty].sort();
            for (const faculty of sortedFaculty) {
                const availableSlots = teacherAvailabilityMap.get(faculty) || [];
                const sortedSlots = [...availableSlots].sort();
                const parsedSlots = sortedSlots.map(s => parseTimeSlot(s)).filter(Boolean);
                const conflictingSlots = new Set();
                for (let i = 0; i < parsedSlots.length; i++) { for (let j = i + 1; j < parsedSlots.length; j++) { const slotA = parsedSlots[i]; const slotB = parsedSlots[j]; const daysOverlap = slotA.days.some(day => slotB.days.includes(day)); if (daysOverlap) { const timesOverlap = (slotA.start < slotB.end) && (slotA.end > slotA.start); if (timesOverlap) { conflictingSlots.add(slotA.id); conflictingSlots.add(slotB.id); } } } }
                const htmlList = sortedSlots.map(slotString => { if (conflictingSlots.has(slotString)) { return `<span style="color: #D93025; font-weight: bold;">${slotString}</span>`; } else { return slotString; } });
                htmlContent += `<div class="schedule-card"><div class="card-header">${faculty}</div><div class="card-body">${htmlList.join('<br>')}</div></div>`;
            }
            container.innerHTML = htmlContent;
        }

        // --- Main & Handlers ---
        let currentWorker = null;
        let workerObjectURL = null;
        
        window.switchPage = function(pageId) {
            document.querySelectorAll('.page-section').forEach(el => el.classList.remove('active-section'));
            document.getElementById('page-' + pageId).classList.add('active-section');
            document.querySelectorAll('nav button').forEach(el => el.classList.remove('active'));
            document.getElementById('nav-' + pageId).classList.add('active');
        };

        document.addEventListener("DOMContentLoaded", function() {
            loadCourses();
            loadAssignments();
            updateSchedulerUI(); // Ensure UI updates after assignments load
            
            try { const blob = new Blob([workerCode], { type: 'application/javascript' }); workerObjectURL = URL.createObjectURL(blob); } catch(e) { console.error(e); }
            document.getElementById("add-course-btn").addEventListener('click', addCourse);
            document.getElementById("course-name-input").addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addCourse(); } });
            document.getElementById("file-uploader").addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                try {
                    currentData = await parseExcelFile(file);
                    document.getElementById("parse-status").textContent = `Loaded: ${currentData.allFaculty.length} faculty.`;
                    document.getElementById("parse-status").style.color = 'green';
                    renderAssignmentTable();
                } catch (e) {
                    console.error(e);
                    document.getElementById("parse-status").textContent = `Error: ${e.message}`;
                    document.getElementById("parse-status").style.color = 'red';
                    currentData = null;
                }
            });
            document.getElementById("generate-btn").addEventListener('click', () => { collectAndSaveAssignments(); switchPage('results'); runOptimizeScheduler(); });

            let timerInterval = null;
            let progressState = { bestScore: Infinity };
            let bestKnownSchedule = new Map();

            async function runOptimizeScheduler() {
                const statusEl = document.getElementById("status-message");
                const singleArea = document.getElementById("single-schedule-results-area");
                const multiArea = document.getElementById("multi-schedule-results-area");
                // Allow mock run if no currentData but assignments exist
                let dataToUse = currentData;
                if (!dataToUse) {
                    if (facultyAssignments.size > 0) {
                        // Create Mock Data Structure
                        const facultyList = Array.from(facultyAssignments.keys());
                        const mockAvail = getMockAvailability(facultyList, MOCK_TIME_SLOTS);
                        dataToUse = {
                            allFaculty: facultyList,
                            allTimeSlots: MOCK_TIME_SLOTS.map(ts => ts.name),
                            allLectureSlots: getMockLectureSlots(),
                            teacherAvailabilityMap: mockAvail.teacherAvailabilityMap,
                            facultyPreferredSlots: mockAvail.facultyPreferredSlots,
                            transferableFacultyPreferredSlots: Array.from(mockAvail.facultyPreferredSlots.entries()).map(([k, v]) => [k, Array.from(v)])
                        };
                    } else {
                        statusEl.textContent = "No data loaded."; return; 
                    }
                }
                
                if (currentWorker) { currentWorker.terminate(); currentWorker = null; }
                if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }

                statusEl.textContent = "Running initial heuristics...";
                statusEl.className = "info";
                statusEl.style.display = 'block';
                document.getElementById("progress-container").style.display = 'block';
                singleArea.innerHTML = "";
                multiArea.style.display = 'block';

                const { allFaculty, allTimeSlots, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, transferableFacultyPreferredSlots } = dataToUse;
                
                const workerFacultyList = [];
                const assignmentDetailsMap = new Map();
                allFaculty.forEach(fac => {
                    const assignments = facultyAssignments.get(fac);
                    if (assignments && assignments.length > 0) {
                        assignments.forEach((assign, idx) => {
                            const key = `${fac}||${idx}`;
                            workerFacultyList.push(key);
                            assignmentDetailsMap.set(key, assign.course);
                        });
                    }
                });
                
                if (workerFacultyList.length === 0) { statusEl.textContent = "No courses assigned."; statusEl.className = "failure"; return; }

                const hardcodedAssignments = [];
                const rows = document.querySelectorAll(".hardcode-row");
                rows.forEach(row => {
                    const ts = row.querySelector(".hc-timeslot").value;
                    const fac = row.querySelector(".hc-course").value;
                    if (ts && fac) {
                        hardcodedAssignments.push({ ts: ts, fac: fac });
                    }
                });

                // 3. Run Heuristics (Main Thread)
                const heuristicResults = [];
                
                // Strategy 1 (Enforces 5-day rule)
                const h1 = runHeuristic('MRV', workerFacultyList, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, assignmentDetailsMap, hardcodedAssignments);
                heuristicResults.push({ name: `Strategy 1: MRV + Happy First (Conflicts: ${h1.numUnhappy})`, description: "MRV + Happy First. <b>Ensures no 5-day weeks.</b>", schedule: h1.schedule, numUnhappy: h1.numUnhappy });
                
                // Strategy 2 (Enforces 5-day rule)
                const h2 = runHeuristic('LCV', workerFacultyList, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, assignmentDetailsMap, hardcodedAssignments);
                heuristicResults.push({ name: `Strategy 2: MRV + LCV (Conflicts: ${h2.numUnhappy})`, description: "MRV + LCV. <b>Ensures no 5-day weeks.</b>", schedule: h2.schedule, numUnhappy: h2.numUnhappy });

                // Strategy 3 (Enforces 5-day rule)
                const h3 = runHeuristic('SCARCITY', workerFacultyList, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, assignmentDetailsMap, hardcodedAssignments);
                heuristicResults.push({ name: `Strategy 3: MRV + Scarcity (Conflicts: ${h3.numUnhappy})`, description: "MRV + Scarcity. <b>Ensures no 5-day weeks.</b>", schedule: h3.schedule, numUnhappy: h3.numUnhappy });

                // NEW: Strategy 4 (IGNORES 5-day rule)
                const h4 = runHeuristic('NO_LIMIT', workerFacultyList, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, assignmentDetailsMap, hardcodedAssignments);
                heuristicResults.push({ name: `Strategy 4: MRV + Happy (No 5-Day Limit) (Conflicts: ${h4.numUnhappy})`, description: "Standard MRV + Happy First, but <b>ignores the 5-day work week limit</b>. Use this to see if the constraint is causing high conflict scores.", schedule: h4.schedule, numUnhappy: h4.numUnhappy });

                multiArea.innerHTML = '<h3 style="border-bottom:1px solid #ccc;">Heuristic Pre-Check</h3>';
                renderMultipleHeuristics(heuristicResults, allTimeSlots, allLectureSlots, multiArea);

                let bestHeuristic = heuristicResults.reduce((best, current) => current.numUnhappy < best.numUnhappy ? current : best, heuristicResults[0]);
                progressState.bestScore = bestHeuristic.numUnhappy;
                bestKnownSchedule = bestHeuristic.schedule;

                singleArea.innerHTML = '<h3 style="border-bottom:1px solid #ccc;">Best Solution (Optimizing...)</h3>';
                renderSingleSchedule(bestKnownSchedule, allTimeSlots, allLectureSlots, singleArea);
                statusEl.textContent = "Heuristics completed. Running the brute force..";
                
                const startTime = performance.now();
                document.getElementById("timer-label").textContent = "Time: 0.0s";
                timerInterval = setInterval(() => { document.getElementById("timer-label").textContent = formatTime((performance.now() - startTime) / 1000); }, 100);

                try { currentWorker = new Worker(workerObjectURL); } catch(e) { console.error(e); return; }

                currentWorker.onmessage = (event) => {
                    const data = event.data;
                    if (data.type === 'progressUpdate') {
                        const pct = ((data.facultyIndex / (data.totalToAssign || 1)) * 100).toFixed(1);
                        document.getElementById("progress-bar").style.width = pct + '%';
                        document.getElementById("progress-label").textContent = `Optimizing... (${pct}%)`;
                        document.getElementById("combo-label").textContent = `Combinations: ${data.combinations.toLocaleString()}`;
                    } else if (data.type === 'solutionUpdate') {
                        if (data.score < progressState.bestScore) {
                            progressState.bestScore = data.score;
                            bestKnownSchedule = new Map(data.schedule);
                            singleArea.innerHTML = '<h3 style="border-bottom:1px solid #ccc;">New Best Solution!</h3>';
                            renderSingleSchedule(bestKnownSchedule, allTimeSlots, allLectureSlots, singleArea);
                            statusEl.textContent = `New best found! Conflicts: ${progressState.bestScore}.`;
                            statusEl.className = "improved";
                        }
                    } else if (data.type === 'complete') {
                        clearInterval(timerInterval);
                        document.getElementById("progress-container").style.display = 'none';
                        const dur = (performance.now() - startTime) / 1000;
                        statusEl.textContent = `Complete. Final conflicts: ${progressState.bestScore}. (${dur.toFixed(1)}s)`;
                        statusEl.className = "success";
                        if (data.finalScore < bestHeuristic.numUnhappy) {
                             singleArea.innerHTML = '<h3 style="border-bottom:1px solid #ccc;">Final Optimal Solution</h3>';
                             renderSingleSchedule(bestKnownSchedule, allTimeSlots, allLectureSlots, singleArea);
                        } else {
                             singleArea.innerHTML = '<h3 style="border-bottom:1px solid #ccc;">Heuristic Solution (Was Optimal)</h3>';
                        }
                    }
                };

                currentWorker.postMessage({
                     allFaculty: workerFacultyList,
                     allLectureSlots,
                     teacherAvailabilityMap: Array.from(teacherAvailabilityMap.entries()),
                     facultyPreferredSlots: transferableFacultyPreferredSlots,
                     initialBestScore: progressState.bestScore,
                     assignmentDetails: Array.from(assignmentDetailsMap.entries()),
                     hardcodedAssignments: hardcodedAssignments 
                });
            }
            window.addEventListener('beforeunload', () => { if (workerObjectURL) URL.revokeObjectURL(workerObjectURL); if (currentWorker) currentWorker.terminate(); });
        });
    </script>
</body>
</html>
