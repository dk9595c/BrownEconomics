<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Faculty Scheduler</title>
    
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0 auto;
            padding: 20px;
            max-width: 1200px;
            background-color: #f4f4f9;
            color: #333;
        }
        h1 {
            color: #004a9c;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
        }
        h2 {
             color: #004a9c;
             border-bottom: 1px solid #ddd;
             padding-bottom: 8px;
             margin-top: 30px;
        }
        h3 {
            color: #333;
            margin-top: 25px;
            margin-bottom: 10px;
            border-bottom: 1px dashed #ccc;
            padding-bottom: 5px;
        }

        /* --- Navigation Styles --- */
        nav {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        nav button {
            font-size: 1.0em;
            padding: 8px 12px;
            border: none;
            background-color: #ddd;
            color: #333;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s;
            margin-right: 5px;
        }
        nav button:hover {
            background-color: #ccc;
        }
        nav button.active {
            background-color: #004a9c;
            color: white;
            font-weight: bold;
        }
        
        /* --- Page Sections --- */
        .page-section {
            display: none;
        }
        .page-section.active-section {
            display: block;
        }

        /* --- Upload & Warning --- */
        #upload-container {
            padding: 20px;
            background-color: #fff;
            border: 2px dashed #004a9c;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        #upload-container label {
            font-weight: bold;
            font-size: 1.1em;
            color: #004a9c;
            margin-right: 10px;
        }
        #file-uploader {
            border: 1px solid #ccc;
            padding: 5px;
            border-radius: 4px;
        }
        #parse-status {
            margin-top: 10px;
            font-style: italic;
            font-size: 0.9em;
        }
        
        #course-requirement-warning {
            padding: 30px;
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 8px;
            color: #856404;
            text-align: center;
            margin-bottom: 20px;
            display: none;
        }
        #course-requirement-warning button {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #856404;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #course-requirement-warning button:hover {
            background-color: #6d5204;
        }

        /* --- Assignment Table --- */
        #assignment-area {
            margin-top: 20px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            display: none;
        }
        table.assignment-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        table.assignment-table th, table.assignment-table td {
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid #eee;
        }
        table.assignment-table th {
            background-color: #f9f9f9;
            color: #004a9c;
        }
        table.assignment-table select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #generate-btn {
            display: block;
            width: 100%;
            padding: 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #generate-btn:hover {
            background-color: #218838;
        }

        /* --- Course Entry --- */
        #course-entry-container {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        #course-form {
            display: grid;
            grid-template-columns: 1fr 120px;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
            border-bottom: 1px dashed #eee;
            padding-bottom: 15px;
        }
        #course-form input[type="text"] {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1.0em;
        }
        #course-form button {
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #course-form button:hover {
            background-color: #0056b3;
        }
        
        #course-list {
            list-style: none;
            padding: 0;
        }
        #course-list li {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #course-list li span.course-details {
            font-weight: bold;
            color: #333;
        }
        #course-list li button.remove-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
        }
        #course-list li button.remove-btn:hover {
            background-color: #c82333;
        }

        /* --- Progress & Results --- */
        #status-message {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 10px;
            padding: 12px;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
            border: 1px solid transparent;
            display: none;
        }
        #status-message.success { display: block; color: #155724; background-color: #d4edda; border-color: #c3e6cb; }
        #status-message.failure { display: block; color: #721c24; background-color: #f8d7da; border-color: #f5c6cb; }
        #status-message.improved { display: block; color: #004085; background-color: #cce5ff; border-color: #b8daff; }
        #status-message.info { display: block; color: #0c5460; background-color: #d1ecf1; border-color: #bee5eb; }

        #progress-container {
            width: 100%;
            margin-bottom: 20px;
            display: none;
        }
        #stats-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
            font-family: monospace;
            color: #333;
        }
        #progress-bar-outline { width: 100%; height: 20px; background-color: #eee; border: 1px solid #ccc; border-radius: 5px; overflow: hidden; }
        #progress-bar { width: 0%; height: 100%; background-color: #004a9c; transition: width 0.1s linear; }
        #progress-label { text-align: left; font-style: italic; margin-top: 5px; color: #555; }

        .card-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .schedule-card { background-color: #ffffff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); overflow: hidden; }
        .card-header { font-weight: bold; background-color: #f9f9f9; padding: 12px 15px; border-bottom: 1px solid #eee; color: #004a9c; }
        .card-body { padding: 15px; font-size: 1.0em; color: #444; line-height: 1.7; }
        .card-body strong { color: #000; } .card-body em { color: #888; }
        
        /* Unhappy status style */
        .card-body strong.unhappy {
            color: #B22222;
            background-color: #f8d7da;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* NEW: Course Tag Style (Small grey box) */
        .course-tag {
            display: inline-block;
            background-color: #f0f0f0;
            color: #555;
            padding: 1px 6px;
            border-radius: 4px;
            font-size: 0.85em;
            margin-left: 8px;
            border: 1px solid #ddd;
            vertical-align: middle;
        }

        #multi-schedule-results-area { display: none; }
        
        details.heuristic-details {
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fdfdfd;
            margin-bottom: 10px;
        }
        summary.heuristic-summary {
            font-size: 1.25em;
            font-weight: bold;
            color: #333;
            padding: 12px 15px;
            cursor: pointer;
            list-style: none;
        }
        summary.heuristic-summary::-webkit-details-marker { display: none; }
        summary.heuristic-summary::before {
            content: '▶ ';
            font-size: 0.8em;
            margin-right: 8px;
            transition: transform 0.1s linear;
        }
        details[open] > summary.heuristic-summary::before {
            content: '▼ ';
        }
        div.heuristic-content {
            padding: 0 15px 15px 35px;
            border-top: 1px dashed #ccc;
        }
    </style>
</head>
<body>

    <h1>Faculty Scheduler</h1>

    <nav>
        <button id="nav-courses" class="active" onclick="switchPage('courses')">1. Course Entry</button>
        <button id="nav-faculty" onclick="switchPage('faculty')">2. Faculty & Assignments</button>
        <button id="nav-results" onclick="switchPage('results')">3. Schedule Results</button>
        <button id="nav-availability" onclick="switchPage('availability')">4. Availability</button>
    </nav>
    
    <main id="page-courses" class="page-section active-section">
        <h2>Course Management</h2>
        <div id="course-entry-container">
            <h3>Add New Course</h3>
            <div id="course-form">
                <input type="text" id="course-name-input" placeholder="Course Name (e.g., Intro to CS, CHEM 101)" required>
                <button id="add-course-btn">Add Course</button>
            </div>
            
            <h3>Current Courses (<span id="course-count">0</span>)</h3>
            <ul id="course-list">
                </ul>
        </div>
    </main>

    <main id="page-faculty" class="page-section">
        <h2>Faculty & Assignments</h2>
        
        <div id="course-requirement-warning">
            <h3>Prerequisites Not Met</h3>
            <p>You must add at least one course in "Course Entry" before uploading a schedule.</p>
            <button onclick="switchPage('courses')">Go to Course Entry</button>
        </div>

        <div id="upload-container">
            <label for="file-uploader">Upload Schedule File (.xlsm, .xlsx):</label>
            <input type="file" id="file-uploader" accept=".xlsx, .xlsm" />
            <div id="parse-status">Please select a file to begin.</div>
        </div>

        <div id="assignment-area">
            <h3>Assign Courses to Faculty</h3>
            <p style="margin-bottom: 15px; color: #555;">Match each faculty member loaded from the Excel file to a course and section.</p>
            <table class="assignment-table">
                <thead>
                    <tr>
                        <th style="width: 40%;">Faculty Name</th>
                        <th style="width: 40%;">Assigned Course</th>
                        <th style="width: 20%;">Section</th>
                    </tr>
                </thead>
                <tbody id="assignment-table-body">
                    </tbody>
            </table>
            <button id="generate-btn">Generate Schedule</button>
        </div>
    </main>

    <main id="page-results" class="page-section">
        <h2>Schedule Optimization Results</h2>
        
        <div id="status-message">Ready to generate.</div>
        <div id="progress-container">
            <div id="stats-container">
                <div id="timer-label">Time: 0.0s</div>
                <div id="combo-label">Combinations: 0</div>
            </div>
            <div id="progress-bar-outline">
                <div id="progress-bar"></div>
            </div>
            <div id="progress-label">Starting...</div>
        </div>
        <div id="single-schedule-results-area"></div>
        <div id="multi-schedule-results-area"></div>
    </main>

    <main id="page-availability" class="page-section">
        <h2>Faculty Availability</h2>
        <div id="availability-container" class="card-container"></div>
    </main>

    <script>

        // --- EMBEDDED WORKER CODE ---
        const workerCode = `
            // --- scheduler_worker.js content START ---
            const parseTimeSlotCache = new Map();
            function parseTimeSlot(timeString) {
                if (!timeString) return null;
                if (parseTimeSlotCache.has(timeString)) {
                    return parseTimeSlotCache.get(timeString);
                }
                const dayPartMatch = timeString.match(/^(MWF|TTh|M|W|F|T|Th)\\s+/);
                if (!dayPartMatch) { console.error('Worker: Invalid day part', timeString); return null; }
                const dayStr = dayPartMatch[1];
                let days = [];
                if (dayStr === 'MWF') days = ['M', 'W', 'F'];
                else if (dayStr === 'TTh') days = ['T', 'H'];
                else if (dayStr === 'T') days = ['T'];
                else if (dayStr === 'Th') days = ['H']; 
                else days = dayStr.split(''); 
                const timePart = timeString.substring(dayStr.length).trim();
                const timeMatch = timePart.match(/^(\\d{1,2})(?::(\\d{2}))?\\s*-\\s*(\\d{1,2})(?::(\\d{2}))?$/);
                if (!timeMatch) { console.error('Worker: Invalid time part', timeString); return null; }
                let startHour = parseInt(timeMatch[1], 10);
                let startMin = parseInt(timeMatch[2] || '0', 10);
                let endHour = parseInt(timeMatch[3], 10);
                let endMin = parseInt(timeMatch[4] || '0', 10);
                if (startHour >= 1 && startHour <= 5) startHour += 12;
                if (endHour >= 1 && endHour <= 5) endHour += 12;
                const startTimeInMinutes = (startHour * 60) + startMin;
                const endTimeInMinutes = (endHour * 60) + endMin;
                const result = { id: timeString, days: days, start: startTimeInMinutes, end: endTimeInMinutes };
                parseTimeSlotCache.set(timeString, result);
                return result;
            }
            
            function hasConflict(newSlotObject, assignedSlotObjects) {
                if (!newSlotObject) return true; 
                for (const assigned of assignedSlotObjects) {
                    const daysOverlap = newSlotObject.days.some(day => assigned.days.includes(day));
                    if (daysOverlap) {
                        const timesOverlap = (newSlotObject.start < assigned.end) && (newSlotObject.end > assigned.start);
                        if (timesOverlap) return true;
                    }
                }
                return false;
            }

            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
            function yieldWorker() { return new Promise(resolve => setTimeout(resolve, 0)); }
            async function solveFullSearchInWorker(allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, initialBestScore) {
                const schedule = new Map(); const assignedLectureSlots = new Set(); 
                const facultyTimeSlotMap = new Map(); 
                let progressState = { facultyIndex: 0, combinations: 0, bestScore: initialBestScore };
                const lectureSlotsByTime = new Map(); for (const l of allLectureSlots) { if (!lectureSlotsByTime.has(l.timeSlot)) lectureSlotsByTime.set(l.timeSlot, []); lectureSlotsByTime.get(l.timeSlot).push(l); }
                
                async function solveForFaculty(facultyIndex, currentUnhappy) {
                    if (currentUnhappy >= progressState.bestScore) return;
                    progressState.facultyIndex = facultyIndex;
                    if (facultyIndex === allFaculty.length) { progressState.bestScore = currentUnhappy; self.postMessage({ type: 'solutionUpdate', schedule: Array.from(schedule.entries()), score: currentUnhappy }); return; }
                    const faculty = allFaculty[facultyIndex];
                    if (progressState.combinations % 1000 === 0) { self.postMessage({ type: 'progressUpdate', facultyIndex: facultyIndex, facultyName: faculty, combinations: progressState.combinations }); await yieldWorker(); }
                    
                    const assignedSlots = facultyTimeSlotMap.get(faculty) || []; 
                    const preferredSlots = facultyPreferredSlots.get(faculty) || new Set(); 
                    const possible = [];
                    
                    for (const l of allLectureSlots) { 
                        if (!assignedLectureSlots.has(l.id) && !hasConflict(l.timeSlotObject, assignedSlots)) { 
                            const isHappy = preferredSlots.has(l.timeSlot);
                            possible.push({ lecture: l, isHappy: isHappy }); 
                        } 
                    }
                    possible.sort((a, b) => b.isHappy - a.isHappy);
                    
                    for (const { lecture, isHappy } of possible) {
                        progressState.combinations++; const newUnhappy = currentUnhappy + (isHappy ? 0 : 1);
                        
                        schedule.set(faculty, { lecture: lecture, isHappy: isHappy }); 
                        assignedLectureSlots.add(lecture.id); 
                        assignedSlots.push(lecture.timeSlotObject);
                        facultyTimeSlotMap.set(faculty, assignedSlots); 
                        
                        await solveForFaculty(facultyIndex + 1, newUnhappy);
                        
                        schedule.delete(faculty); 
                        assignedLectureSlots.delete(lecture.id); 
                        assignedSlots.pop();
                    }
                }
                const shuffledFaculty = shuffleArray([...allFaculty]); await solveForFaculty(0, 0);
                return { finalCombinations: progressState.combinations, finalScore: progressState.bestScore };
            }
            self.onmessage = async (event) => {
                parseTimeSlotCache.clear(); 
                const { allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, initialBestScore } = event.data;
                try {
                    const reconstructedTeacherAvailabilityMap = new Map(teacherAvailabilityMap);
                    const reconstructedFacultyPreferredSlots = new Map(facultyPreferredSlots.map(([k, v]) => [k, new Set(v)]));
                    
                    const allLectureSlotsParsed = allLectureSlots.map(l => ({
                        ...l,
                        timeSlotObject: parseTimeSlot(l.timeSlot) 
                    })).filter(l => l.timeSlotObject); 

                    if (allLectureSlotsParsed.length !== allLectureSlots.length) {
                        throw new Error("One or more time slots could not be parsed in the worker.");
                    }

                    const result = await solveFullSearchInWorker(
                        allFaculty, 
                        allLectureSlotsParsed, 
                        reconstructedTeacherAvailabilityMap, 
                        reconstructedFacultyPreferredSlots, 
                        initialBestScore
                    );
                    self.postMessage({ type: 'complete', ...result });
                } catch (error) { console.error("Error in worker:", error); self.postMessage({ type: 'error', message: error.message }); }
            }; 
            // --- scheduler_worker.js content END ---
        `;

        // --- HELPER FUNCTIONS ---
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
        function formatTime(totalSeconds) { if (totalSeconds >= 3600) { const h = Math.floor(totalSeconds / 3600); const r = totalSeconds % 3600; const m = Math.floor(r / 60); const s = r % 60; return `Time: ${h}h ${m}m ${s.toFixed(1)}s`; } if (totalSeconds >= 60) { const m = Math.floor(totalSeconds / 60); const s = totalSeconds % 60; return `Time: ${m}m ${s.toFixed(1)}s`; } return `Time: ${totalSeconds.toFixed(1)}s`; }
        
        // --- Time Parsing Logic (Main Thread) ---
        const parseTimeSlotCache = new Map();
        function parseTimeSlot(timeString) {
            if (!timeString) return null;
            if (parseTimeSlotCache.has(timeString)) return parseTimeSlotCache.get(timeString);
            const dayPartMatch = timeString.match(/^(MWF|TTh|M|W|F|T|Th)\s+/);
            if (!dayPartMatch) { console.error("Main: Invalid time slot day format:", timeString); return null; }
            const dayStr = dayPartMatch[1];
            let days = [];
            if (dayStr === 'MWF') days = ['M', 'W', 'F'];
            else if (dayStr === 'TTh') days = ['T', 'H'];
            else if (dayStr === 'T') days = ['T'];
            else if (dayStr === 'Th') days = ['H'];
            else days = dayStr.split('');
            const timePart = timeString.substring(dayStr.length).trim();
            const timeMatch = timePart.match(/^(\d{1,2})(?::(\d{2}))?\s*-\s*(\d{1,2})(?::(\d{2}))?$/);
            if (!timeMatch) { console.error("Main: Invalid time slot time format:", timeString); return null; }
            let startHour = parseInt(timeMatch[1], 10);
            let startMin = parseInt(timeMatch[2] || '0', 10);
            let endHour = parseInt(timeMatch[3], 10);
            let endMin = parseInt(timeMatch[4] || '0', 10);
            if (startHour >= 1 && startHour <= 5) startHour += 12;
            if (endHour >= 1 && endHour <= 5) endHour += 12;
            const result = { id: timeString, days: days, start: (startHour * 60) + startMin, end: (endHour * 60) + endMin };
            parseTimeSlotCache.set(timeString, result);
            return result;
        }

        function hasConflict(newSlotObject, assignedSlotObjects) {
             if (!newSlotObject) return true;
            for (const assigned of assignedSlotObjects) {
                const daysOverlap = newSlotObject.days.some(day => assigned.days.includes(day));
                if (daysOverlap) {
                    const timesOverlap = (newSlotObject.start < assigned.end) && (newSlotObject.end > assigned.start);
                    if (timesOverlap) return true;
                }
            }
            return false;
        }

        // --- HEURISTICS (Unchanged logic) ---
        function runHeuristicMRVRandom(allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots) {
             const schedule = new Map(); const assignedLectureSlots = new Set(); const facultyTimeSlotMap = new Map(); let numUnhappy = 0;
             const lectureSlotsByTime = new Map(); for (const l of allLectureSlots) { if (!lectureSlotsByTime.has(l.timeSlot)) lectureSlotsByTime.set(l.timeSlot, []); lectureSlotsByTime.get(l.timeSlot).push(l); }
             const sortedFaculty = [...allFaculty].sort((a, b) => (teacherAvailabilityMap.get(a)?.length || 0) - (teacherAvailabilityMap.get(b)?.length || 0));
             for (const faculty of sortedFaculty) {
                const assignedSlots = facultyTimeSlotMap.get(faculty) || []; let placed = false;
                const prefSlots = teacherAvailabilityMap.get(faculty) || []; const prefSet = facultyPreferredSlots.get(faculty) || new Set(); let potentialHappy = [];
                for (const ts of prefSlots) { (lectureSlotsByTime.get(ts) || []).forEach(l => { if (!assignedLectureSlots.has(l.id) && !hasConflict(l.timeSlotObject, assignedSlots)) { potentialHappy.push(l); } }); }
                if (potentialHappy.length > 0) { shuffleArray(potentialHappy); const chosen = potentialHappy[0]; schedule.set(faculty, { lecture: chosen, isHappy: true }); assignedLectureSlots.add(chosen.id); assignedSlots.push(chosen.timeSlotObject); facultyTimeSlotMap.set(faculty, assignedSlots); placed = true; }
                if (!placed) { let potentialUnhappy = []; for (const l of allLectureSlots) { if (!assignedLectureSlots.has(l.id) && !hasConflict(l.timeSlotObject, assignedSlots) && !prefSet.has(l.timeSlot)) { potentialUnhappy.push(l); } }
                    if (potentialUnhappy.length > 0) { shuffleArray(potentialUnhappy); const chosen = potentialUnhappy[0]; schedule.set(faculty, { lecture: chosen, isHappy: false }); assignedLectureSlots.add(chosen.id); assignedSlots.push(chosen.timeSlotObject); facultyTimeSlotMap.set(faculty, assignedSlots); numUnhappy++; placed = true; }
                }
                 if (!placed) { let failsafe = []; for (const l of allLectureSlots) { if (!assignedLectureSlots.has(l.id) && !hasConflict(l.timeSlotObject, assignedSlots)) { failsafe.push(l); } }
                      if(failsafe.length > 0) { shuffleArray(failsafe); const chosen = failsafe[0]; const isHappy = prefSet.has(chosen.timeSlot); schedule.set(faculty, { lecture: chosen, isHappy: isHappy }); assignedLectureSlots.add(chosen.id); assignedSlots.push(chosen.timeSlotObject); facultyTimeSlotMap.set(faculty, assignedSlots); if (!isHappy) numUnhappy++; placed = true; } else { console.error("H1 fail: " + faculty); }
                 }
            }
            return { name: `Strategy 1: Fewest Preferences + Random Choice (Conflicts: ${numUnhappy})`, description: "This strategy prioritizes faculty with the fewest preferred slots (MRV). It tries to place them first by randomly picking one of their available preferred slots.", schedule, numUnhappy };
        }
        function runHeuristicMRV_LCV(allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots) {
             const schedule = new Map(); const assignedLectureSlots = new Set(); const facultyTimeSlotMap = new Map(); let numUnhappy = 0; let unassigned = new Set(allFaculty);
             const lectureSlotsByTime = new Map(); for (const l of allLectureSlots) { if (!lectureSlotsByTime.has(l.timeSlot)) lectureSlotsByTime.set(l.timeSlot, []); lectureSlotsByTime.get(l.timeSlot).push(l); }
             let facultyToAssign = [...allFaculty].sort((a, b) => (teacherAvailabilityMap.get(a)?.length || 0) - (teacherAvailabilityMap.get(b)?.length || 0));
             for (const faculty of facultyToAssign) {
                if (!unassigned.has(faculty)) continue;
                const assignedSlots = facultyTimeSlotMap.get(faculty) || []; const prefSet = facultyPreferredSlots.get(faculty) || new Set(); let placed = false; let potentialHappy = [];
                for (const ts of prefSet) { (lectureSlotsByTime.get(ts) || []).forEach(l => { if (!assignedLectureSlots.has(l.id) && !hasConflict(l.timeSlotObject, assignedSlots)) { let score = 0; unassigned.forEach(o => { if (o !== faculty && (facultyPreferredSlots.get(o) || new Set()).has(ts)) score++; }); potentialHappy.push({ lecture: l, score: score }); } }); }
                if (potentialHappy.length > 0) { potentialHappy.sort((a, b) => a.score - b.score); const bestScore = potentialHappy[0].score; const best = potentialHappy.filter(s => s.score === bestScore); const chosen = shuffleArray(best)[0].lecture; schedule.set(faculty, { lecture: chosen, isHappy: true }); assignedLectureSlots.add(chosen.id); assignedSlots.push(chosen.timeSlotObject); facultyTimeSlotMap.set(faculty, assignedSlots); unassigned.delete(faculty); placed = true; }
                if (!placed) { let potentialUnhappy = []; for (const l of allLectureSlots) { if (!assignedLectureSlots.has(l.id) && !hasConflict(l.timeSlotObject, assignedSlots) && !prefSet.has(l.timeSlot)) { let score = 0; unassigned.forEach(o => { if (o !== faculty && (facultyPreferredSlots.get(o) || new Set()).has(l.timeSlot)) score++; }); potentialUnhappy.push({ lecture: l, score: score }); } }
                    if (potentialUnhappy.length > 0) { potentialUnhappy.sort((a, b) => a.score - b.score); const bestScore = potentialUnhappy[0].score; const best = potentialUnhappy.filter(s => s.score === bestScore); const chosen = shuffleArray(best)[0].lecture; schedule.set(faculty, { lecture: chosen, isHappy: false }); assignedLectureSlots.add(chosen.id); assignedSlots.push(chosen.timeSlotObject); facultyTimeSlotMap.set(faculty, assignedSlots); unassigned.delete(faculty); numUnhappy++; placed = true; }
                }
                 if (!placed) { let failsafe = []; for (const l of allLectureSlots) { if (!assignedLectureSlots.has(l.id) && !hasConflict(l.timeSlotObject, assignedSlots)) { failsafe.push(l); } }
                      if(failsafe.length > 0) { shuffleArray(failsafe); const chosen = failsafe[0]; const isHappy = prefSet.has(chosen.timeSlot); schedule.set(faculty, { lecture: chosen, isHappy: isHappy }); assignedLectureSlots.add(chosen.id); assignedSlots.push(chosen.timeSlotObject); facultyTimeSlotMap.set(faculty, assignedSlots); unassigned.delete(faculty); if (!isHappy) numUnhappy++; placed = true; } else { console.error("H2 fail: " + faculty); }
                 }
            }
            return { name: `Strategy 2: Fewest Preferences + Quietest Slot (Conflicts: ${numUnhappy})`, description: "This smarter strategy also picks faculty with the fewest preferences (MRV) first. However, it assigns them to the 'quietest' slot (LCV), the one that is least desired by other unassigned faculty, saving the more popular slots for later.", schedule, numUnhappy };
        }
        function runHeuristicSlotScarcity(allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots) {
             const schedule = new Map(); const assignedLectureSlots = new Set(); const facultyTimeSlotMap = new Map(); let numUnhappy = 0; let unassigned = new Set(allFaculty); let unassignedSlots = new Set(allLectureSlots.map(l => l.id)); const lectureLookup = new Map(allLectureSlots.map(l => [l.id, l]));
             while (unassigned.size > 0 && unassignedSlots.size > 0) {
                 let minCount = Infinity; let potentials = [];
                 for (const sId of unassignedSlots) { const l = lectureLookup.get(sId); let prefCount = 0; let currentFacs = []; unassigned.forEach(f => { const assignedSlots = facultyTimeSlotMap.get(f) || []; if ((facultyPreferredSlots.get(f) || new Set()).has(l.timeSlot) && !hasConflict(l.timeSlotObject, assignedSlots)) { prefCount++; currentFacs.push(f); } }); if (prefCount > 0 && prefCount < minCount) { minCount = prefCount; potentials = [{ slotId: sId, facultyList: currentFacs }]; } else if (prefCount > 0 && prefCount === minCount) { potentials.push({ slotId: sId, facultyList: currentFacs }); } }
                 if (potentials.length === 0) { minCount = Infinity; potentials = []; for (const sId of unassignedSlots) { const l = lectureLookup.get(sId); let anyCount = 0; let currentAnyFacs = []; unassigned.forEach(f => { const assignedSlots = facultyTimeSlotMap.get(f) || []; if (!hasConflict(l.timeSlotObject, assignedSlots)) { anyCount++; currentAnyFacs.push(f); } }); if (anyCount > 0 && anyCount < minCount) { minCount = anyCount; potentials = [{ slotId: sId, facultyList: currentAnyFacs }]; } else if (anyCount > 0 && anyCount === minCount) { potentials.push({ slotId: sId, facultyList: currentAnyFacs }); } } if(potentials.length === 0){ console.error("H3 fallback fail."); break; } }
                 const chosenInfo = shuffleArray(potentials)[0]; const chosenSId = chosenInfo.slotId; const candidates = chosenInfo.facultyList; candidates.sort((a, b) => (teacherAvailabilityMap.get(a)?.length || 0) - (teacherAvailabilityMap.get(b)?.length || 0)); const chosenFac = candidates[0]; const chosenLec = lectureLookup.get(chosenSId); const isHappy = (facultyPreferredSlots.get(chosenFac) || new Set()).has(chosenLec.timeSlot);
                 schedule.set(chosenFac, { lecture: chosenLec, isHappy: isHappy }); assignedLectureSlots.add(chosenLec.id); unassignedSlots.delete(chosenLec.id); unassigned.delete(chosenFac); const assignedSlots = facultyTimeSlotMap.get(chosenFac) || []; assignedSlots.push(chosenLec.timeSlotObject); facultyTimeSlotMap.set(chosenFac, assignedSlots); if (!isHappy) numUnhappy++;
            }
             if (unassigned.size > 0) { console.warn(`H3: ${unassigned.size} unplaced, forcing.`); for(const f of unassigned) { let placed = false; const assignedSlots = facultyTimeSlotMap.get(f) || []; for (const l of allLectureSlots) { if (!assignedLectureSlots.has(l.id) && !hasConflict(l.timeSlotObject, assignedSlots)) { const isHappy = (facultyPreferredSlots.get(f) || new Set()).has(l.timeSlot); schedule.set(f, { lecture: l, isHappy: isHappy }); assignedLectureSlots.add(l.id); assignedSlots.push(l.timeSlotObject); facultyTimeSlotMap.set(f, assignedSlots); if (!isHappy) numUnhappy++; placed = true; break; } } if(!placed) console.error("H3 Failsafe fail: " + f); } }
            return { name: `Strategy 3: Scarcest Slot First (Conflicts: ${numUnhappy})`, description: "This strategy focuses on the time slots, not the faculty. It finds the 'scarcest' slot (preferred by the fewest people) and assigns it. To decide who gets that slot, it gives it to the faculty member who has the fewest other preferences (MRV tie-breaker).", schedule, numUnhappy };
        }

        // --- GLOBAL STATE ---
        const COURSE_STORAGE_KEY = 'facultySchedulerCourses';
        let courses = [];
        let currentData = null; // Excel data
        let facultyAssignments = new Map(); // Faculty Name -> { course: string, section: string }
        
        // --- Course Functions ---
        function loadCourses() {
            try {
                const stored = localStorage.getItem(COURSE_STORAGE_KEY);
                courses = stored ? JSON.parse(stored) : [];
            } catch (e) {
                courses = [];
            }
            renderCourseList();
            updateSchedulerUI();
        }

        function saveCourses() {
            try {
                localStorage.setItem(COURSE_STORAGE_KEY, JSON.stringify(courses));
                updateSchedulerUI();
            } catch (e) {
                console.error(e);
            }
        }
        
        function renderCourseList() {
            const listEl = document.getElementById("course-list");
            const listContainer = document.getElementById("course-entry-container").querySelector("h3 span");
            if(listContainer) listContainer.textContent = courses.length;
            
            listEl.innerHTML = '';
            courses.forEach((course, index) => {
                const li = document.createElement('li');
                li.innerHTML = `<span class="course-details">${course.name}</span> <button class="remove-btn" onclick="removeCourse(${index})">Remove</button>`;
                listEl.appendChild(li);
            });
        }

        function removeCourse(index) {
            courses.splice(index, 1);
            renderCourseList();
            saveCourses();
        }
        
        function addCourse() {
            const nameInput = document.getElementById("course-name-input");
            const name = nameInput.value.trim();
            if (!name) return;
            if (courses.some(c => c.name.toLowerCase() === name.toLowerCase())) {
                alert("Course already exists.");
                return;
            }
            courses.push({ name: name });
            renderCourseList();
            saveCourses();
            nameInput.value = '';
            nameInput.focus();
        }

        function updateSchedulerUI() {
            const warningEl = document.getElementById("course-requirement-warning");
            const uploadEl = document.getElementById("upload-container");
            const assignArea = document.getElementById("assignment-area");

            if (courses.length > 0) {
                warningEl.style.display = 'none';
                uploadEl.style.display = 'block';
                // Keep assignment area visible if data is loaded
                if (currentData) assignArea.style.display = 'block';
            } else {
                warningEl.style.display = 'block';
                uploadEl.style.display = 'none';
                assignArea.style.display = 'none';
            }
        }

        // --- Excel Parsing ---
        async function parseExcelFile(file) {
            parseTimeSlotCache.clear();
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });

                        const facultySheet = workbook.Sheets['Faculty'];
                        if (!facultySheet) reject(new Error("Sheet 'Faculty' not found."));
                        const facultyJson = XLSX.utils.sheet_to_json(facultySheet, { header: 1 });
                        const allFaculty = facultyJson.map(row => row[0]).filter(Boolean);
                        
                        const timeSlotsSheet = workbook.Sheets['TimeSlots'];
                        if (!timeSlotsSheet) reject(new Error("Sheet 'TimeSlots' not found."));
                        const timeSlotsJson = XLSX.utils.sheet_to_json(timeSlotsSheet);
                        
                        const allTimeSlots = [];
                        const allLectureSlots = [];
                        for (const row of timeSlotsJson) {
                            const slotName = row['Time Slot Name'];
                            const numRooms = parseInt(row['Number of Rooms'], 10);
                            if (slotName && numRooms > 0) {
                                const parsedSlot = parseTimeSlot(slotName);
                                if (!parsedSlot) {
                                    reject(new Error(`Could not parse time slot: "${slotName}".`));
                                    return;
                                }
                                allTimeSlots.push(slotName);
                                for (let i = 1; i <= numRooms; i++) {
                                    allLectureSlots.push({ id: `${slotName} (Room ${i})`, timeSlot: slotName, timeSlotObject: parsedSlot });
                                }
                            }
                        }
                        if (allFaculty.length > allLectureSlots.length) { reject(new Error(`Impossible schedule: ${allFaculty.length} faculty but only ${allLectureSlots.length} rooms.`)); return; }
                        
                        const availabilitySheet = workbook.Sheets['Availability'];
                        if (!availabilitySheet) reject(new Error("Sheet 'Availability' not found."));
                        const availabilityJson = XLSX.utils.sheet_to_json(availabilitySheet, { header: 1 });
                        
                        const timeSlotHeaders = availabilityJson[0].slice(1);
                        const facultyAvailabilityRows = availabilityJson.slice(1);
                        
                        const teacherAvailabilityMap = new Map();
                        const facultyPreferredSlots = new Map();
                        
                        for (const row of facultyAvailabilityRows) {
                            const facultyName = row[0];
                            if (facultyName) {
                                const preferredSlots = [];
                                const preferredSlotSet = new Set();
                                row.slice(1).forEach((cell, index) => {
                                    if (cell && ['x', '1', 'y', 'yes'].includes(String(cell).toLowerCase())) {
                                        const slotName = timeSlotHeaders[index];
                                        if (slotName) preferredSlots.push(slotName); preferredSlotSet.add(slotName);
                                    }
                                });
                                teacherAvailabilityMap.set(facultyName, preferredSlots);
                                facultyPreferredSlots.set(facultyName, preferredSlotSet);
                            }
                        }
                        const transferableFacultyPreferredSlots = Array.from(facultyPreferredSlots.entries()).map(([k, v]) => [k, Array.from(v)]);
                        resolve({ allFaculty, allTimeSlots, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, transferableFacultyPreferredSlots });
                    } catch (e) { reject(e); }
                };
                reader.readAsArrayBuffer(file);
            });
        }

        // --- Assignments UI ---
        function renderAssignmentTable() {
            const tbody = document.getElementById("assignment-table-body");
            tbody.innerHTML = "";
            const assignArea = document.getElementById("assignment-area");

            if (!currentData || !currentData.allFaculty) return;

            // Generate options for courses
            let options = `<option value="">-- Select Course --</option>`;
            courses.forEach(c => {
                options += `<option value="${c.name}">${c.name}</option>`;
            });

            // Options for section
            let sectionOptions = `<option value="NA">NA</option>
                                  <option value="Section-1">Section-1</option>
                                  <option value="Section-2">Section-2</option>
                                  <option value="Section-3">Section-3</option>`;

            currentData.allFaculty.forEach(fac => {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${fac}</td>
                    <td>
                        <select class="course-select" data-faculty="${fac}">
                            ${options}
                        </select>
                    </td>
                    <td>
                        <select class="section-select" data-faculty="${fac}">
                            ${sectionOptions}
                        </select>
                    </td>
                `;
                tbody.appendChild(tr);
            });

            assignArea.style.display = "block";
        }

        function collectAssignments() {
            facultyAssignments.clear();
            const rows = document.querySelectorAll("#assignment-table-body tr");
            rows.forEach(row => {
                const fac = row.querySelector(".course-select").getAttribute("data-faculty");
                const course = row.querySelector(".course-select").value;
                const section = row.querySelector(".section-select").value;
                if (course) {
                    facultyAssignments.set(fac, { course: course, section: section });
                }
            });
        }

        // --- Render Results (Corrected Format) ---
        function renderSingleSchedule(schedule, allTimeSlots, allLectureSlots, containerEl) {
            const assignedMap = new Map();
            for (const [f, a] of schedule.entries()) { assignedMap.set(a.lecture.id, { faculty: f, isHappy: a.isHappy }); }
            const tsGroup = new Map(); for (const ts of allTimeSlots) { tsGroup.set(ts, []); }
            
            for (const l of allLectureSlots) {
                const rName = l.id.substring(l.timeSlot.length).trim();
                const assign = assignedMap.get(l.id);
                let assignStr;
                if (assign) {
                    const uhCls = assign.isHappy ? '' : 'class="unhappy"';
                    
                    // Construct Display
                    const assignment = facultyAssignments.get(assign.faculty);
                    let courseDisplay = "";
                    if (assignment) {
                        let cText = assignment.course;
                        if (assignment.section && assignment.section !== "NA") {
                            cText += ` [${assignment.section}]`;
                        }
                        courseDisplay = `<span class="course-tag">${cText}</span>`;
                    }

                    assignStr = `${rName}: <strong ${uhCls}>${assign.faculty}</strong>${courseDisplay}`;
                } else {
                    assignStr = `${rName}: <em>(Unassigned)</em>`;
                }
                tsGroup.get(l.timeSlot).push(assignStr);
            }
            let htmlContent = `<div class="card-container">`;
            const sortedTS = [...allTimeSlots].sort();
            for (const ts of sortedTS) {
                const assigns = tsGroup.get(ts) || [];
                htmlContent += `<div class="schedule-card"><div class="card-header">${ts}</div><div class="card-body">${assigns.join('<br>')}</div></div>`;
            }
            htmlContent += `</div>`; containerEl.innerHTML = htmlContent;
        }

        function renderMultipleHeuristics(results, allTimeSlots, allLectureSlots, containerEl) {
             const schemes = [{ headerBg: '#f0f6ff', headerColor: '#004a9c', cardBorder: '#b8daff' }, { headerBg: '#f0fff0', headerColor: '#155724', cardBorder: '#c3e6cb' }, { headerBg: '#fffaf0', headerColor: '#856404', cardBorder: '#ffeeba' }];
             let fullHtml = "";
             results.forEach((result, index) => {
                const colors = schemes[index % schemes.length];
                fullHtml += `<details class="heuristic-details"><summary class="heuristic-summary">${result.name}</summary><div class="heuristic-content">`;
                if(result.description) { fullHtml += `<p style="margin-top: 10px; margin-bottom: 20px; font-size: 0.9em; font-style: italic; max-width: 800px; color: #333;">${result.description}</p>`; }
                const assignedMap = new Map(); for (const [f, a] of result.schedule.entries()) { assignedMap.set(a.lecture.id, { faculty: f, isHappy: a.isHappy }); } const tsGroup = new Map(); for (const ts of allTimeSlots) { tsGroup.set(ts, []); }
                for (const l of allLectureSlots) {
                    const rName = l.id.substring(l.timeSlot.length).trim();
                    const assign = assignedMap.get(l.id);
                    let assignStr;
                    if (assign) {
                        const uhCls = assign.isHappy ? '' : 'class="unhappy"';
                        
                        // Construct Display
                        const assignment = facultyAssignments.get(assign.faculty);
                        let courseDisplay = "";
                        if (assignment) {
                            let cText = assignment.course;
                            if (assignment.section && assignment.section !== "NA") {
                                cText += ` [${assignment.section}]`;
                            }
                            courseDisplay = `<span class="course-tag">${cText}</span>`;
                        }

                        assignStr = `${rName}: <strong ${uhCls}>${assign.faculty}</strong>${courseDisplay}`;
                    } else { assignStr = `${rName}: <em>(Unassigned)</em>`; }
                    tsGroup.get(l.timeSlot).push(assignStr);
                }
                fullHtml += `<div class="card-container">`; const sortedTS = [...allTimeSlots].sort(); for (const ts of sortedTS) { const assigns = tsGroup.get(ts) || []; const cardStyle = `border: 1px solid ${colors.cardBorder};`; const headerStyle = `background-color: ${colors.headerBg}; color: ${colors.headerColor};`; fullHtml += `<div class="schedule-card" style="${cardStyle}"><div class="card-header" style="${headerStyle}">${ts}</div><div class="card-body">${assigns.join('<br>')}</div></div>`; }
                fullHtml += `</div></div></details>`;
             });
             containerEl.innerHTML = fullHtml;
        }

        function renderAvailabilityPage(allFaculty, teacherAvailabilityMap, container) {
            let htmlContent = `<p style="margin-bottom: 15px; font-style: italic; font-size: 0.9em; padding: 10px; background-color: #f9f9f9; border-radius: 5px;">`;
            htmlContent += `<b>Legend:</b> <span style="color: #D93025; font-weight: bold;">Red text</span> indicates preferred time slots that overlap with each other.</p>`;
             const sortedFaculty = [...allFaculty].sort();
            for (const faculty of sortedFaculty) {
                const availableSlots = teacherAvailabilityMap.get(faculty) || [];
                const sortedSlots = [...availableSlots].sort();
                const parsedSlots = sortedSlots.map(s => parseTimeSlot(s)).filter(Boolean);
                const conflictingSlots = new Set();
                for (let i = 0; i < parsedSlots.length; i++) { for (let j = i + 1; j < parsedSlots.length; j++) { const slotA = parsedSlots[i]; const slotB = parsedSlots[j]; const daysOverlap = slotA.days.some(day => slotB.days.includes(day)); if (daysOverlap) { const timesOverlap = (slotA.start < slotB.end) && (slotA.end > slotB.start); if (timesOverlap) { conflictingSlots.add(slotA.id); conflictingSlots.add(slotB.id); } } } }
                const htmlList = sortedSlots.map(slotString => { if (conflictingSlots.has(slotString)) { return `<span style="color: #D93025; font-weight: bold;">${slotString}</span>`; } else { return slotString; } });
                htmlContent += `<div class="schedule-card"><div class="card-header">${faculty}</div><div class="card-body">${htmlList.join('<br>')}</div></div>`;
            }
            container.innerHTML = htmlContent;
        }

        // --- Main & Handlers ---
        let currentWorker = null;
        let workerObjectURL = null;
        
        window.switchPage = function(pageId) {
            document.querySelectorAll('.page-section').forEach(el => el.classList.remove('active-section'));
            document.getElementById('page-' + pageId).classList.add('active-section');
            document.querySelectorAll('nav button').forEach(el => el.classList.remove('active'));
            document.getElementById('nav-' + pageId).classList.add('active');
        };

        document.addEventListener("DOMContentLoaded", function() {
            
            loadCourses();
            
            try {
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                workerObjectURL = URL.createObjectURL(blob);
            } catch(e) { console.error(e); }

            document.getElementById("add-course-btn").addEventListener('click', addCourse);
            document.getElementById("course-name-input").addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); addCourse(); }
            });

            // Upload
            document.getElementById("file-uploader").addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const parseStatus = document.getElementById("parse-status");
                parseStatus.textContent = "Parsing Excel file...";
                parseStatus.style.color = '#333';

                try {
                    currentData = await parseExcelFile(file);
                    parseStatus.textContent = `Loaded: ${currentData.allFaculty.length} faculty.`;
                    parseStatus.style.color = 'green';
                    
                    renderAvailabilityPage(currentData.allFaculty, currentData.teacherAvailabilityMap, document.getElementById("availability-container"));
                    
                    // Show assignments table
                    renderAssignmentTable();

                } catch (e) {
                    console.error("Error parsing file:", e);
                    parseStatus.textContent = `Error: ${e.message}`;
                    parseStatus.style.color = 'red';
                    currentData = null;
                }
            });

            // Generate Button
            document.getElementById("generate-btn").addEventListener('click', () => {
                collectAssignments(); // Save dropdown values
                switchPage('results'); // Move to tab 3
                runOptimizeScheduler(); // Start logic
            });

            // Optimization Logic
            let timerInterval = null;
            let progressState = { bestScore: Infinity };
            let bestKnownSchedule = new Map();

            async function runOptimizeScheduler() {
                const statusEl = document.getElementById("status-message");
                const singleArea = document.getElementById("single-schedule-results-area");
                const multiArea = document.getElementById("multi-schedule-results-area");
                
                if (!currentData) {
                    statusEl.textContent = "No data loaded.";
                    return;
                }

                if (currentWorker) { currentWorker.terminate(); currentWorker = null; }
                if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }

                statusEl.textContent = "Running initial heuristics...";
                statusEl.className = "info";
                statusEl.style.display = 'block';
                document.getElementById("progress-container").style.display = 'block';
                singleArea.innerHTML = "";
                multiArea.style.display = 'block';

                const { allFaculty, allTimeSlots, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots, transferableFacultyPreferredSlots } = currentData;
                
                progressState.bestScore = Infinity;
                bestKnownSchedule = new Map();

                // 1. Run Heuristics
                const heuristicResults = [];
                heuristicResults.push(runHeuristicMRVRandom(allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots));
                heuristicResults.push(runHeuristicMRV_LCV(allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots));
                heuristicResults.push(runHeuristicSlotScarcity(allFaculty, allLectureSlots, teacherAvailabilityMap, facultyPreferredSlots));

                multiArea.innerHTML = '<h3 style="border-bottom:1px solid #ccc;">Heuristic Pre-Check</h3>';
                renderMultipleHeuristics(heuristicResults, allTimeSlots, allLectureSlots, multiArea);

                let bestHeuristic = heuristicResults[0];
                for(const result of heuristicResults) { if (result.numUnhappy < bestHeuristic.numUnhappy) { bestHeuristic = result; } }
                progressState.bestScore = bestHeuristic.numUnhappy;
                bestKnownSchedule = bestHeuristic.schedule;

                singleArea.innerHTML = '<h3 style="border-bottom:1px solid #ccc;">Best Solution (Optimizing...)</h3>';
                renderSingleSchedule(bestKnownSchedule, allTimeSlots, allLectureSlots, singleArea);

                statusEl.textContent = "Heuristics completed. Running the brute force..";
                
                // 2. Start Worker
                const startTime = performance.now();
                const timerLabel = document.getElementById("timer-label");
                timerInterval = setInterval(() => {
                    timerLabel.textContent = formatTime((performance.now() - startTime) / 1000);
                }, 100);

                try { currentWorker = new Worker(workerObjectURL); } catch(e) { console.error(e); return; }

                currentWorker.onmessage = (event) => {
                    const data = event.data;
                    const pBar = document.getElementById("progress-bar");
                    const pLabel = document.getElementById("progress-label");
                    const cLabel = document.getElementById("combo-label");

                    if (data.type === 'progressUpdate') {
                        const pct = (data.facultyIndex / allFaculty.length) * 100;
                        pBar.style.width = pct + '%';
                        pLabel.textContent = `Optimizing: ${data.facultyName}...`;
                        cLabel.textContent = `Combinations: ${data.combinations.toLocaleString()}`;
                    } else if (data.type === 'solutionUpdate') {
                        if (data.score < progressState.bestScore) {
                            progressState.bestScore = data.score;
                            bestKnownSchedule = new Map(data.schedule);
                            singleArea.innerHTML = '<h3 style="border-bottom:1px solid #ccc;">New Best Solution!</h3>';
                            renderSingleSchedule(bestKnownSchedule, allTimeSlots, allLectureSlots, singleArea);
                            statusEl.textContent = `New best found! Conflicts: ${progressState.bestScore}.`;
                            statusEl.className = "improved";
                        }
                    } else if (data.type === 'complete') {
                        clearInterval(timerInterval);
                        document.getElementById("progress-container").style.display = 'none';
                        const dur = (performance.now() - startTime) / 1000;
                        statusEl.textContent = `Complete. Final conflicts: ${progressState.bestScore}. (${dur.toFixed(1)}s)`;
                        statusEl.className = "success";
                        
                        if (data.finalScore < bestHeuristic.numUnhappy) {
                             singleArea.innerHTML = '<h3 style="border-bottom:1px solid #ccc;">Final Optimal Solution</h3>';
                             renderSingleSchedule(bestKnownSchedule, allTimeSlots, allLectureSlots, singleArea);
                        } else {
                             singleArea.innerHTML = '<h3 style="border-bottom:1px solid #ccc;">Heuristic Solution (Was Optimal)</h3>';
                        }
                    }
                };

                currentWorker.postMessage({
                     allFaculty, allLectureSlots,
                     teacherAvailabilityMap: Array.from(teacherAvailabilityMap.entries()),
                     facultyPreferredSlots: transferableFacultyPreferredSlots,
                     initialBestScore: progressState.bestScore
                });
            }

            window.addEventListener('beforeunload', () => {
                 if (workerObjectURL) { URL.revokeObjectURL(workerObjectURL); }
                 if (currentWorker) { currentWorker.terminate(); }
            });
        });
    </script>
</body>
</html>
